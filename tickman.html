<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG Stickman - Pencil Edition</title>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

<style>
body {
    margin: 0;            /* X√≥a l·ªÅ m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
    padding: 0;           /* X√≥a kho·∫£ng ƒë·ªám */
    width: 100%;          /* Chi·ªÅu r·ªông 100% m√†n h√¨nh */
    height: 100%;         /* Chi·ªÅu cao 100% m√†n h√¨nh */
    background-color: #000; /* M√†u n·ªÅn ƒëen (ƒë·ªÉ che nh·ªØng ch·ªó game ch∆∞a load) */
    overflow: hidden;     /* QUAN TR·ªåNG: ·∫®n thanh cu·ªôn ƒë·ªÉ kh√¥ng b·ªã tr∆∞·ª£t lung tung */
    touch-action: none;   /* Ch·∫∑n h√†nh ƒë·ªông zoom/k√©o c·ªßa tr√¨nh duy·ªát tr√™n ƒëi·ªán tho·∫°i */
    user-select: none;    /* Kh√¥ng cho b√¥i ƒëen vƒÉn b·∫£n */
    -webkit-user-select: none;
}
/* Hi·ªáu ·ª©ng n√∫t T·∫†O ph√°t s√°ng (Nh·∫•p nh√°y v√†ng kim) */
@keyframes pulse-gold {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7);
        transform: scale(1);
        border-color: #ffd700;
        color: #ffd700;
    }
    50% {
        box-shadow: 0 0 15px 10px rgba(255, 215, 0, 0);
        transform: scale(1.05); /* Ph√≥ng to nh·∫π */
        border-color: #fff;
        color: #fff;
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 215, 0, 0);
        transform: scale(1);
        border-color: #ffd700;
        color: #ffd700;
    }
}

/* Class n√†y s·∫Ω ƒë∆∞·ª£c th√™m v√†o n√∫t T·∫†O b·∫±ng Javascript */
.btn-highlight {
    animation: pulse-gold 1.5s infinite; /* Ch·∫°y li√™n t·ª•c */
    font-weight: bold !important;
    background-color: rgba(255, 215, 0, 0.1) !important; /* N·ªÅn v√†ng m·ªù */
}

/* 2. Giao di·ªán Th√¥ng b√°o (Toast) bay l√™n */
#toast-notification {
    visibility: hidden; /* M·∫∑c ƒë·ªãnh ·∫©n */
    min-width: 250px;
    background-color: rgba(20, 30, 35, 0.95); /* N·ªÅn t·ªëi */
    color: #46c846; /* Ch·ªØ xanh l√° */
    text-align: center;
    border-radius: 50px; /* Bo tr√≤n */
    border: 1px solid #46c846;
    padding: 12px 20px;
    position: fixed;
    z-index: 9999; /* N·∫±m tr√™n c√πng m·ªçi th·ª© */
    left: 50%;
    bottom: 30px; /* V·ªã tr√≠ b·∫Øt ƒë·∫ßu */
    transform: translateX(-50%);
    font-size: 16px;
    font-weight: bold;
    box-shadow: 0 0 20px rgba(70, 200, 70, 0.4);
    opacity: 0;
    transition: opacity 0.5s, bottom 0.5s; /* Hi·ªáu ·ª©ng m∆∞·ª£t */
}

/* Khi hi·ªán l√™n th√¨ th√™m class n√†y */
#toast-notification.show {
    visibility: visible;
    opacity: 1;
    bottom: 80px; /* Bay l√™n cao h∆°n */
}
</style>
</head>
<body>

<div id="avatarMenu" style="display: none; position: fixed; top: 70px; left: 15px; width: 100px; background: rgba(20, 30, 35, 0.95); border: 1px solid #78b4b4; border-radius: 8px; z-index: 3000; box-shadow: 0 4px 10px rgba(0,0,0,0.5); overflow: hidden; transition: all 0.3s ease;">
    
    <button id="btnCreate" onclick="actionCreate()" style="width: 100%; padding: 12px 0; background: transparent; border: none; border-bottom: 1px solid #3c5a5a; color: #888; font-weight: bold; cursor: pointer; transition: 0.2s;">
        T·∫†O
    </button>
    
    <button id="btnDelete" onclick="actionDelete()" style="width: 100%; padding: 12px 0; background: transparent; border: none; border-bottom: 1px solid #3c5a5a; color: #ff4444; font-weight: bold; cursor: pointer; transition: 0.2s;">
        XO√Å
    </button>
    
    <button id="btnSaveManual" onclick="actionSaveManual()" style="width: 100%; padding: 12px 0; background: transparent; border: none; color: #ffd700; font-weight: bold; cursor: pointer; transition: 0.2s;">
        L∆ØU
    </button>
</div>

<div id="interactBtn" onclick="openShop()" style="display: none; position: fixed; bottom: 150px; right: 120px; width: 60px; height: 60px; background: rgba(255, 215, 0, 0.9); border: 2px solid #fff; border-radius: 50%; z-index: 1000; color: #000; font-weight: bold; font-size: 14px; text-align: center; line-height: 60px; box-shadow: 0 0 15px #ffd700; cursor: pointer;">
    MUA
</div>

<div id="shopModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 30, 35, 0.98); border: 2px solid #5aaab4; padding: 15px; border-radius: 10px; color: #fff; z-index: 2000; width: 300px; box-shadow: 0 0 20px rgba(90, 170, 180, 0.5); font-family: Arial, sans-serif;">
    <h2 style="text-align: center; margin: 0 0 15px 0; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 10px;">üè™ D∆∞·ª£c Sƒ©</h2>
    
    <div id="shopItems">
        <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); margin-bottom: 10px; padding: 8px; border-radius: 5px;">
            <img src="1008.png" style="width: 32px; height: 32px; margin-right: 10px;">
            <div style="flex-grow: 1;">
                <div style="font-weight: bold; font-size: 14px;">B√¨nh M√°u</div>
                <div style="color: #ffd700; font-size: 12px;">100 ü•ú</div>
            </div>
            <button onclick="buyItem('HP_POTION', 100, 'B√¨nh M√°u', '1008')" style="background: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Mua</button>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); margin-bottom: 10px; padding: 8px; border-radius: 5px;">
            <img src="1009.png" style="width: 32px; height: 32px; margin-right: 10px;">
            <div style="flex-grow: 1;">
                <div style="font-weight: bold; font-size: 14px;">B√¨nh Mana</div>
                <div style="color: #ffd700; font-size: 12px;">100 ü•ú</div>
            </div>
            <button onclick="buyItem('MP_POTION', 100, 'B√¨nh Mana', '1009')" style="background: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Mua</button>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); margin-bottom: 10px; padding: 8px; border-radius: 5px;">
            <img src="1010.png" style="width: 32px; height: 32px; margin-right: 10px;">
            <div style="flex-grow: 1;">
                <div style="font-weight: bold; font-size: 14px;">B√¨nh H·ªón H·ª£p</div>
                <div style="color: #ffd700; font-size: 12px;">200 ü•ú</div>
            </div>
            <button onclick="buyItem('DUAL_POTION', 200, 'B√¨nh H·ªón H·ª£p', '1010')" style="background: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Mua</button>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); margin-bottom: 10px; padding: 8px; border-radius: 5px;">
            <img src="1011.png" style="width: 32px; height: 32px; margin-right: 10px;">
            <div style="flex-grow: 1;">
                <div style="font-weight: bold; font-size: 14px;">B√¨nh Th·ªÉ L·ª±c</div>
                <div style="color: #ffd700; font-size: 12px;">300 ü•ú</div>
            </div>
            <button onclick="buyItem('STAMINA_POTION', 300, 'B√¨nh Th·ªÉ L·ª±c', '1011')" style="background: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Mua</button>
        </div>
    </div>
    
    <button onclick="closeShop()" style="width: 100%; padding: 10px; background: #dc3545; color: white; border: none; border-radius: 5px; margin-top: 10px; font-weight: bold;">ƒê√≥ng C·ª≠a H√†ng</button>
</div>
<div id="nameModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 30, 35, 0.98); border: 2px solid #5aaab4; padding: 20px; border-radius: 10px; z-index: 4000; width: 280px; box-shadow: 0 0 20px rgba(90, 170, 180, 0.5); text-align: center; font-family: Arial, sans-serif;">
    <h3 style="color: #ffd700; margin: 0 0 15px 0; border-bottom: 1px solid #555; padding-bottom: 10px;">NH·∫¨P T√äN NH√ÇN V·∫¨T</h3>
    
    <input type="text" id="playerNameInput" maxlength="10" placeholder="T√™n c·ªßa b·∫°n..." style="width: 80%; padding: 10px; margin-bottom: 20px; border-radius: 5px; border: 1px solid #78b4b4; background: #0f1e23; color: white; font-weight: bold; text-align: center; font-size: 16px; outline: none;">
    
    <div style="display: flex; justify-content: space-between;">
        <button onclick="closeNameModal()" style="flex: 1; background: #dc3545; color: white; padding: 10px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-right: 5px;">H·ª¶Y</button>
        <button onclick="confirmCreate()" style="flex: 1; background: #28a745; color: white; padding: 10px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-left: 5px;">X√ÅC NH·∫¨N</button>
    </div>
</div>

<div id="toast-notification">‚úÖ ƒê√£ l∆∞u d·ªØ li·ªáu th√†nh c√¥ng!</div>
<script>
// --- C·∫§U H√åNH PHASER ---
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#f5f5f0',
    parent: document.body,
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

function preload() {
    // T·∫£i to√†n b·ªô ·∫£nh
    this.load.image("1003", "1003.png");
    this.load.image("1004", "1004.png");
    this.load.image("1005", "1005.png");
    this.load.image("1006", "1006.png");
    this.load.image("1007", "1007.png");
    this.load.image("1008", "1008.png");
    this.load.image("1009", "1009.png");
    this.load.image("1012", "1012.png");
    this.load.image("1013", "1013.png");
    this.load.image("1017", "1017.png");
    this.load.image("1018", "1018.png");
    this.load.image("1019", "1019.png");
    this.load.image("1020", "1020.png");
    this.load.image("1024", "1024.png");
    this.load.image("1025", "1025.png");

    let loadingText = this.add.text(window.innerWidth / 2, window.innerHeight / 2, 'ƒêang t·∫£i...', { fontSize: '20px', fill: '#000' });
    loadingText.setOrigin(0.5);
    
    this.load.on('complete', function () {
        loadingText.destroy();
        console.log(">>> Phaser ƒë√£ t·∫£i xong ·∫£nh!");
    });
}

function create() {
    // 1. N·∫†P ·∫¢NH T·ª™ PHASER SANG LOGIC C≈®
    const keys = ["1003", "1004", "1005", "1006", "1007", "1008", "1009", "1012", "1013", "1017", "1018", "1019", "1020", "1024", "1025"];
    
    keys.forEach(key => {
        if (this.textures.exists(key)) {
            // L∆∞u ·∫£nh v√†o bi·∫øn to√†n c·ª•c 'images' ƒë·ªÉ code c≈© v·∫Ω ƒë∆∞·ª£c
            images[key] = this.textures.get(key).getSourceImage();
        }
    });

    // 2. T·∫†O L·ªöP GAME CH√çNH (ƒê·∫•t & Nh√¢n v·∫≠t)
    this.cameras.main.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    // T·∫°o Canvas Texture (L·ªõp v·∫Ω trong su·ªët n·∫±m ƒë√® l√™n Background)
    canvasTexture = this.textures.createCanvas('gameLayer', SCREEN_WIDTH, SCREEN_HEIGHT);
    
    let gameLayerImage = this.add.image(0, 0, 'gameLayer');
    gameLayerImage.setOrigin(0);
    gameLayerImage.setScrollFactor(0);
    gameLayerImage.setDepth(0); // N·∫±m tr√™n Background 1001

    // G√°n context ƒë·ªÉ code c≈© v·∫Ω v√†o ƒë√¢y
    ctx = canvasTexture.context;
    
    this.scale.on('resize', function (gameSize) {
        SCREEN_WIDTH = gameSize.width;
        SCREEN_HEIGHT = gameSize.height;

        // C·∫≠p nh·∫≠t l·∫°i k√≠ch th∆∞·ªõc c·ªßa l·ªõp v·∫Ω ·∫£o (CanvasTexture)
        if (canvasTexture) {
            canvasTexture.canvas.width = SCREEN_WIDTH;
            canvasTexture.canvas.height = SCREEN_HEIGHT;
            canvasTexture.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        }
    });

    // 3. THI·∫æT L·∫¨P INPUT V√Ä LOGIC GAME
    this.input.addPointer(2); 
    
    this.input.on('pointerdown', function (pointer) {
        handleStart(pointer.x, pointer.y, pointer.id);
    });

    this.input.on('pointermove', function (pointer) {
        handleMove(pointer.x, pointer.y, pointer.id);
    });

    this.input.on('pointerup', function (pointer) {
        handleEnd(pointer.id);
    });

    // Ki·ªÉm tra Save game
    if (loadGame(player, inventory)) {
        console.log(">>> Phaser: T·∫£i l·∫°i game c≈© th√†nh c√¥ng!");
        isGameActive = true; 
    } else {
        console.log(">>> Phaser: Ch∆∞a c√≥ save, ch·ªù t·∫°o m·ªõi.");
        isGameActive = false; 
        player.x = -9999; 
        
        setTimeout(() => {
            if (typeof toggleAvatarMenu === "function") {
                toggleAvatarMenu();
            }
        }, 500);
    }
    
    console.log(">>> ƒê√£ k·∫øt n·ªëi Logic c≈© v√†o Phaser!");
}

function update(time, delta) {
    if (!ctx) return;

    // --- 1. X·ª¨ L√ù ZOOM (K√âO 2 NG√ìN TAY) ---
    // Ki·ªÉm tra n·∫øu c√≥ 2 ng√≥n tay c√πng ch·∫°m v√†o m√†n h√¨nh
    if (this.input.pointer1.isDown && this.input.pointer2.isDown) {
        // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ng√≥n tay
        let dist = Phaser.Math.Distance.Between(
            this.input.pointer1.x, this.input.pointer1.y,
            this.input.pointer2.x, this.input.pointer2.y
        );

        if (initialPinchDist === 0) {
            // N·∫øu m·ªõi b·∫Øt ƒë·∫ßu ch·∫°m 2 ng√≥n -> L∆∞u l·∫°i kho·∫£ng c√°ch g·ªëc
            initialPinchDist = dist;
            startZoom = gameZoom;
        } else {
            // N·∫øu ƒëang k√©o -> T√≠nh t·ª∑ l·ªá thay ƒë·ªïi
            let scale = dist / initialPinchDist;
            // Gi·ªõi h·∫°n zoom: Nh·ªè nh·∫•t 0.6 (xa) - L·ªõn nh·∫•t 1.5 (g·∫ßn)
            gameZoom = Phaser.Math.Clamp(startZoom * scale, 0.6, 1.5);
        }
    } else {
        // Khi nh·∫£ tay ra -> Reset l·∫°i ƒë·ªÉ ch·ªù l·∫ßn k√©o sau
        initialPinchDist = 0;
    }

    // --- 2. X√ìA M√ÄN H√åNH ---
    ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    // --- 3. C·∫¨P NH·∫¨T LOGIC GAME (Kh√¥ng v·∫Ω, ch·ªâ t√≠nh to√°n) ---
    if (player) {
        this.cameras.main.startFollow(player, true, 0.1, 0.1);
    }
    // L·∫•y t·ªça ƒë·ªô Camera
    let camX = this.cameras.main.scrollX;
    let camY = this.cameras.main.scrollY;

    if (isGameActive) {
        player.update(joystick.vector.x, joystick.vector.y);
        
        if (player.hasSlime && !activePet) activePet = new PetSlime(player);
        if (activePet) activePet.update();
        
        updateNPCInteraction();
    }
    
    // Update ƒë·∫°n & ch·ªØ bay
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].update();
        if (bullets[i].life <= 0) bullets.splice(i, 1);
    }
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].update();
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }

    // [B·∫ÆT ƒê·∫¶U V√ôNG ZOOM] - M·ªçi th·ª© v·∫Ω trong n√†y s·∫Ω b·ªã ph√≥ng to/thu nh·ªè
    ctx.save(); 

    // D·ªãch chuy·ªÉn t√¢m v·ªÅ gi·ªØa m√†n h√¨nh ƒë·ªÉ Zoom t·ª´ trung t√¢m t·ªèa ra
    ctx.translate(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);
    ctx.scale(gameZoom, gameZoom);
    ctx.translate(-SCREEN_WIDTH / 2, -SCREEN_HEIGHT / 2);

    // --- V·∫º N·ªÄN M·∫∂T B√ÄN V√Ä T·ªú GI·∫§Y ---
    ctx.save(); 
    ctx.translate(-camX, -camY); 
    
    // ƒê·ªï m√†u m·∫∑t b√†n (M√†u x√°m t·ªëi) xung quanh t·ªù gi·∫•y
    ctx.fillStyle = "#1e1e24"; 
    ctx.fillRect(-4000, -4000, WORLD_WIDTH + 8000, WORLD_HEIGHT + 8000);
    
    // V·∫Ω t·ªù gi·∫•y tr·∫Øng ng√† (B·ªã gi·ªõi h·∫°n ƒë√∫ng b·∫±ng WORLD_WIDTH v√† WORLD_HEIGHT)
    ctx.fillStyle = "#fdfdfb"; 
    ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    // V·∫Ω l∆∞·ªõi √¥ ly tr·ª±c ti·∫øp l√™n t·ªù gi·∫•y
    drawGridLinesOnly();
    
    ctx.restore();

    // 2. V·∫Ω NPC & V·∫≠t c·∫£n
    drawDoraemon(camX, camY);
    drawPharmacist(camX, camY);
    drawBlacksmith(camX, camY);
    drawObstacles(camX, camY);

    // 3. V·∫Ω Player & Pet
    if (isGameActive) {
        player.draw(camX, camY);
        if (activePet) activePet.draw(ctx, camX, camY);
    }

    // 4. V·∫Ω ƒê·∫°n & Effect (L∆∞u √Ω: ƒê·∫°n c·∫ßn tr·ª´ camX, camY v√¨ n√≥ d√πng to·∫° ƒë·ªô th·∫ø gi·ªõi)
    ctx.save();
    ctx.translate(-camX, -camY); 
    bullets.forEach(b => b.draw(ctx));
    ctx.restore();

    floatingTexts.forEach(t => t.draw(ctx));

    // K·∫øt th√∫c v√πng Zoom -> Tr·∫£ l·∫°i tr·∫°ng th√°i b√¨nh th∆∞·ªùng
    ctx.restore();

    // --- 4. V·∫º GIAO DI·ªÜN (UI) --- 
    // (V·∫Ω sau l·ªánh restore() ƒë·ªÉ n√∫t b·∫•m KH√îNG b·ªã ph√≥ng to theo game)
    if (isGameActive) {
        drawTopLeftHUD(player);
        hud.draw(player);
        joystick.draw();
        attackBtn.draw();
        dashButton.draw();
        sitButton.draw();
        miniMap.draw(ctx, player, [], camX, camY);
    } else {
        // M√†n h√¨nh ch·ªù
        let realName = player.name;
        player.name = "MENU";
        drawTopLeftHUD(player);
        player.name = realName;
        drawStartScreenGuide();
    }
    
    // V·∫Ω c√°c b·∫£ng Popup
    if (charPanel.visible) charPanel.draw(player);
    if (inventory.visible) inventory.draw();
    if (skillPanel.visible) skillPanel.draw();

    // L·ªánh b·∫Øt bu·ªôc c·ªßa Phaser ƒë·ªÉ c·∫≠p nh·∫≠t Texture
    canvasTexture.refresh();
}

// --- H√ÄM V·∫º L∆Ø·ªöI PH·ª§ TR·ª¢ (Th√™m h√†m n√†y xu·ªëng d∆∞·ªõi c√πng file ho·∫∑c d∆∞·ªõi update) ---
function drawGridLogic(camera) {
    let camX = camera.scrollX;
    let camY = camera.scrollY;
    
    // V·∫Ω n·ªÅn tr·∫Øng ƒë·ª•c nh·∫π
    ctx.fillStyle = "#f5f5f0";
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    // V·∫Ω l∆∞·ªõi
    let gridW = 40; 
    let sx = -(camX % gridW); 
    let sy = -(camY % gridW);

    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#b4c8ff"; // M√†u xanh ph·∫•n

    // D·ªçc
    for (let x = sx; x < SCREEN_WIDTH; x += gridW) { 
        ctx.moveTo(x, 0); ctx.lineTo(x, SCREEN_HEIGHT); 
    }
    // Ngang
    for (let y = sy; y < SCREEN_HEIGHT; y += gridW) { 
        ctx.moveTo(0, y); ctx.lineTo(SCREEN_WIDTH, y); 
    }
    ctx.stroke();
    
    // V·∫Ω l·ªÅ ƒë·ªè (Safe Zone)
    let marginScreenX = 300 - camX;
    if (marginScreenX > -50 && marginScreenX < SCREEN_WIDTH + 50) {
        ctx.beginPath();
        ctx.moveTo(marginScreenX, 0);
        ctx.lineTo(marginScreenX, SCREEN_HEIGHT);
        ctx.strokeStyle = "#eb3c3c";
        ctx.lineWidth = 2.5; 
        ctx.stroke();
    }
}

// --- C·∫§U H√åNH ---
let SCREEN_WIDTH = window.innerWidth;
let SCREEN_HEIGHT = window.innerHeight;
const images = {};
let gameZoom = 1.0;       // ƒê·ªô ph√≥ng to hi·ªán t·∫°i
let initialPinchDist = 0; // Kho·∫£ng c√°ch 2 ng√≥n tay l√∫c b·∫Øt ƒë·∫ßu ch·∫°m
let startZoom = 1.0;      // L∆∞u ƒë·ªô zoom g·ªëc khi b·∫Øt ƒë·∫ßu k√©o
// Bi·∫øn ch·ª©a Texture ƒë·∫∑c bi·ªát c·ªßa Phaser
let canvasTexture; 
// ƒê·ªÉ ctx l√† null ban ƒë·∫ßu, ta s·∫Ω g√°n n√≥ sau trong h√†m create()
let ctx = null; 

const FPS = 60;
const AUTOSAVE_INTERVAL = 2000;
const WORLD_WIDTH = 1600; 
const WORLD_HEIGHT = 2400; // TƒÉng chi·ªÅu d·ªçc l√™n g·∫•p r∆∞·ª°i
// M√ÄU S·∫ÆC
const COLORS = {
    BG: "#f5f5f0",
    GRID: "#b4c8ff",
    JOYSTICK_OUT: "rgba(200, 200, 200, 0.5)",
    JOYSTICK_IN: "rgba(100, 100, 100, 0.8)",
    PAPER_RED: "#eb3c3c",
    INK_BLACK: "#141414",
    THEME_JADE_BG: "#193c41",
    THEME_JADE_BORDER: "#78b4b4",
    THEME_SLOT_BG: "#0f1e23",
    THEME_SLOT_BORDER: "#3c5a5a",
    THEME_GOLD_ACTIVE: "#dcbe8c",
    THEME_TEXT_WHITE: "#f0f5f5",
    THEME_TEXT_DARK: "#28190a",
    BTN_USE_BG: "#ffcc00",
    BTN_USE_BORDER: "#ffaa00",
    BTN_USE_TEXT: "#5c4008"
};
// --- C·∫§U H√åNH NPC & V·ªä TR√ç ---

const NPC_PHARMACIST = { x: 150, y: 500, interactDist: 100 };
const NPC_DORAEMON   = { x: 150, y: 1000, interactDist: 100 };
const NPC_BLACKSMITH = { x: 150, y: 1500, interactDist: 100 };
// --- 1. DANH S√ÅCH V·∫¨T C·∫¢N (OBSTACLES) ---
const OBSTACLES = [
    // M·ªôt c√°i h·ªì n∆∞·ªõc
    { x: 1200, y: 1200, w: 200, h: 150, type: 'RECT', color: "#0099ff" }
];

// K√≠ch th∆∞·ªõc v√πng va ch·∫°m c·ªßa NPC (ƒë·ªÉ kh√¥ng ƒëi xuy√™n qua h·ªç)
const NPC_HITBOX_SIZE = 40;

// V√ôNG AN TO√ÄN (Safe Zone)
const SAFE_ZONE_X = 300;
// --- H√ÄM L∆ØU GAME "AN TO√ÄN N√ÇNG C·∫§P" ---
function saveGame(player, inventory, silent = true) {
  if (!isGameActive) return;
    // 1. Ki·ªÉm tra xem nh√¢n v·∫≠t v√† t√∫i ƒë·ªì c√≥ t·ªìn t·∫°i kh√¥ng
    if (!player || !inventory) return; 

    // 2. L·∫•y v·ªã tr√≠ Slot (0, 1 ho·∫∑c 2) t·ª´ b·ªô nh·ªõ
    let slotIdxStr = localStorage.getItem("rpg_current_slot_index");

// N·∫øu game b·ªã m·∫•t d·∫•u Slot (th∆∞·ªùng do Acode ƒë·ªïi c·ªïng l√†m m·∫•t localStorage)
    if (slotIdxStr === null || slotIdxStr === undefined) {
        if (!silent) {
            alert("‚ö†Ô∏è C·∫£nh b√°o: K·∫øt n·ªëi d·ªØ li·ªáu b·ªã gi√°n ƒëo·∫°n!\nH·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông l∆∞u v√†o [Slot 1] ƒë·ªÉ c·ª©u d·ªØ li·ªáu.");
        }
        console.warn("M·∫•t d·∫•u Slot! T·ª± ƒë·ªông g√°n v·ªÅ 0 (Slot 1).");
        
        // C∆∞·ª°ng √©p g√°n v·ªÅ Slot 1 ƒë·ªÉ kh√¥ng b·ªã l·ªói code
        slotIdxStr = "0"; 
        localStorage.setItem("rpg_current_slot_index", "0");
    }

    const slotIdx = parseInt(slotIdxStr);
    
    // 3. ƒê√≥ng g√≥i d·ªØ li·ªáu hi·ªán t·∫°i v√†o bi·∫øn
    const currentData = {
        player: player.toDict(),
        inventory: inventory.toDict()
    };
    
    try {
        // L∆∞u m·ªôt b·∫£n d·ª± ph√≤ng ri√™ng l·∫ª (ph√≤ng h·ªù file t·ªïng b·ªã h·ªèng)
        localStorage.setItem("rpg_pencil_backup_last_ss", JSON.stringify(currentData));
        
        // 4. ƒê·ªçc d·ªØ li·ªáu t·ªïng (c·∫£ 3 slot) t·ª´ b·ªô nh·ªõ
        let slotsData = localStorage.getItem("rpg_pencil_slots");
        let slots = [null, null, null]; 

        if (slotsData) {
            try {
                let parsed = JSON.parse(slotsData);
                // N·∫øu ƒë·ªçc ƒë∆∞·ª£c m·∫£ng c≈© th√¨ d√πng, kh√¥ng th√¨ t·∫°o m·ªõi
                if (Array.isArray(parsed)) {
                    slots = parsed;
                }
            } catch(e) {
                console.warn("File t·ªïng b·ªã l·ªói, ƒëang kh·ªüi t·∫°o l·∫°i...", e);
            }
        }

        // ƒê·∫£m b·∫£o lu√¥n c√≥ ƒë·ªß 3 ch·ªó tr·ªëng
        if (!Array.isArray(slots)) slots = [null, null, null];
        while(slots.length < 3) slots.push(null);

        // 5. GHI ƒê√à D·ªÆ LI·ªÜU M·ªöI V√ÄO ƒê√öNG SLOT ƒêANG CH∆†I
        slots[slotIdx] = currentData; 
        
        // Chuy·ªÉn th√†nh chu·ªói vƒÉn b·∫£n ƒë·ªÉ l∆∞u xu·ªëng ·ªï c·ª©ng
        const jsonToSave = JSON.stringify(slots);
        
        // Ki·ªÉm tra an to√†n: Ch·ªâ l∆∞u n·∫øu d·ªØ li·ªáu ƒë·ªß d√†i (tr√°nh l∆∞u ƒë√® file r·ªóng)
        if (jsonToSave.length > 50) {
            localStorage.setItem("rpg_pencil_slots", jsonToSave);
            if (!silent) console.log(`>>> ƒê√£ l∆∞u Game an to√†n v√†o Slot ${slotIdx + 1}`);
        } else {
            console.error("D·ªØ li·ªáu qu√° ng·∫Øn, h·ªßy l∆∞u ƒë·ªÉ tr√°nh h·ªèng file.");
        }

    } catch (e) { 
        console.error("L·ªñI NGHI√äM TR·ªåNG KHI L∆ØU:", e); 
        if (!silent) alert("L·ªói b·ªô nh·ªõ ƒë·∫ßy ho·∫∑c b·ªã ch·∫∑n! H√£y th·ª≠ x√≥a b·ªõt d·ªØ li·ªáu web.");
    }
}

function loadGame(player, inventory) {
    let slotIdxStr = localStorage.getItem("rpg_current_slot_index");
    let slotIdx = slotIdxStr ? parseInt(slotIdxStr) : 0;
    
    let slotsData = localStorage.getItem("rpg_pencil_slots");
    if (!slotsData) return false; 

    try {
        let slots = JSON.parse(slotsData);
        if (!Array.isArray(slots) || !slots[slotIdx]) return false;

        let data = slots[slotIdx]; 

        if (data.player) player.fromDict(data.player);
        if (data.inventory) inventory.fromDict(data.inventory);
        
        // KI·ªÇM TRA T·ªåA ƒê·ªò SAU KHI LOAD
        // N·∫øu nh√¢n v·∫≠t b·ªã k·∫πt ·ªü t·ªça ƒë·ªô √¢m (do l·ªói save l√∫c n√£y), h√£y reset v·ªÅ gi·ªØa map
        if (player.x < 0 || player.y < 0) {
            console.warn("Ph√°t hi·ªán l·ªói Save (nh√¢n v·∫≠t b·ªã ·∫©n). ƒêang reset v·ªã tr√≠...");
            player.x = WORLD_WIDTH / 2;
            player.y = WORLD_HEIGHT / 2;
        }

        return true; 
    } catch (e) {
        console.error("L·ªói khi t·∫£i game:", e);
        return false; 
    }
}
// --- C√ÅC H√ÄM V·∫º H·ªñ TR·ª¢ ---
function drawLine(x1, y1, x2, y2, color, width=1) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.stroke();
}

function drawCircle(x, y, radius, color, isFilled=true, lineWidth=1) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    if (isFilled) { ctx.fillStyle = color; ctx.fill(); } 
    else { ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.stroke(); }
}

function drawRect(x, y, w, h, color, isFilled=true, radius=0, lineWidth=1) {
    ctx.beginPath();
    if (radius > 0) {
        if (ctx.roundRect) ctx.roundRect(x, y, w, h, radius);
        else ctx.rect(x, y, w, h);
    } else { ctx.rect(x, y, w, h); }
    if (isFilled) { ctx.fillStyle = color; ctx.fill(); } 
    else { ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.stroke(); }
}

function drawText(text, x, y, size, color, align="left", bold=true) {
    ctx.font = `${bold ? "bold " : ""}${size}px Arial`;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.textBaseline = "middle";
    ctx.fillText(text, x, y);
    return ctx.measureText(text).width;
}

function drawLimb(start, end, length, color, bendDir=1, width=3) {
    let [x1, y1] = start; let [x2, y2] = end;
    let dist = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
    dist = Math.min(dist, length);
    let midX = (x1 + x2) / 2; let midY = (y1 + y2) / 2;
    let bendAmount = 0;
    if (length > dist) bendAmount = Math.sqrt((length/2)**2 - (dist/2)**2);
    let dx = x2 - x1; let dy = y2 - y1;
    let perpX = -dy / dist; let perpY = dx / dist;
    let jointX = midX + perpX * bendAmount * bendDir;
    let jointY = midY + perpY * bendAmount * bendDir;

    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(jointX, jointY); ctx.lineTo(x2, y2);
    ctx.strokeStyle = color; ctx.lineWidth = width;
    ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
}
// --- QU·∫¢N L√ù S·ªê S√ÅT TH∆Ø∆†NG BAY L√äN ---
const floatingTexts = [];
const bullets = [];

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y;
        this.text = text; this.color = color;
        this.life = 60; 
        this.vy = -2;   
    }
    update() {
        this.x += (Math.random() - 0.5) * 1; 
        this.y += this.vy;
        this.vy *= 0.9; 
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        ctx.shadowColor = "black"; ctx.shadowBlur = 2;
        drawText(this.text, this.x, this.y, 20, this.color, "center", true);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1.0;
    }
}
// --- CLASS: VI√äN ƒê·∫†N M·ª∞C B√öT X√ìA ---
class Bullet {
    constructor(x, y, isRight) {
        this.x = x; 
        this.y = y;
        this.speed = 12;
        this.vx = isRight ? this.speed : -this.speed;
        this.life = 60; // ƒê·∫°n t·ªìn t·∫°i 60 frame (1 gi√¢y)
        this.size = 8;
    }
    update() {
        this.x += this.vx;
        this.life--;
    }
    draw(ctx) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff"; // M√†u tr·∫Øng b√∫t x√≥a
        ctx.fill();
        
        // Vi·ªÅn xanh cho n·ªïi b·∫≠t
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#0096aa"; 
        ctx.stroke();
        
        // Hi·ªáu ·ª©ng v·ªát ƒëu√¥i
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 3, this.y); // V·ªát d√†i ng∆∞·ª£c h∆∞·ªõng bay
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.stroke();
        ctx.restore();
    }
}
// --- CLASS: N√öT T·∫§N C√îNG ---
class AttackButton {
    constructor() {
        this.radius = 20; // <--- Gi·∫£m t·ª´ 40 xu·ªëng 20 cho n√∫t nh·ªè g·ªçn h∆°n
        this.x = 0; this.y = 0;
        this.pressed = false;
        this.cooldown = 0;
    }

    updatePos() {
        // ƒê·∫©y n√∫t s√°t v√†o g√≥c h∆°n m·ªôt ch√∫t v√¨ n√∫t ƒë√£ nh·ªè l·∫°i
        this.x = SCREEN_WIDTH - 60;  // Tr√°i, Ph·∫£i
        this.y = SCREEN_HEIGHT - 100; // L√™n, Xu·ªëng
    }

    checkClick(x, y) {
        let dist = Math.sqrt((x - this.x)**2 + (y - this.y)**2);
        if (dist <= this.radius) {
            this.triggerAttack();
            return true;
        }
        return false;
    }

    triggerAttack() {
        // 1. Ki·ªÉm tra h·ªìi chi√™u
        if (this.cooldown > 0) return;
        
        // 2. K√≠ch ho·∫°t t·∫•n c√¥ng d·ª±a tr√™n v≈© kh√≠
        if (player.equippedWeapon === "PENCIL") {
            // B√∫t Ch√¨: ƒê√°nh nhanh (30 frame h·ªìi chi√™u)
            this.cooldown = 30; 
            player.startAttack(); // M·∫∑c ƒë·ªãnh attackTimer l√† 15
        } 
        else if (player.equippedWeapon === "RULER") {
            // Th∆∞·ªõc K·∫ª: ƒê√°nh ch·∫≠m h∆°n nh∆∞ng ƒë·∫ßm tay (45 frame h·ªìi chi√™u)
            this.cooldown = 45; 
            player.startAttack();
            
            // Ghi ƒë√® th·ªùi gian ho·∫°t ·∫£nh: Ch√©m l√¢u h∆°n ƒë√¢m (20 frame)
            // Gi√∫p c√∫ ch√©m v·∫Ω h·∫øt v√≤ng cung ƒë·∫πp m·∫Øt
            player.attackTimer = 20; 
        } 
        else if (player.equippedWeapon === "CORRECTION_PEN") {
            this.cooldown = 50; // B·∫Øn nhanh (15 frame = 4 vi√™n/gi√¢y)
            player.startAttack();
            
            // --- C·∫¨P NH·∫¨T T·ªåA ƒê·ªò CH√çNH X√ÅC T·∫†I ƒê·∫¶U NG√íI B√öT ---
            let s = player.scale; // L·∫•y t·ªâ l·ªá nh√¢n v·∫≠t (0.6)

            // 1. T√≠nh ƒë·ªô cao (Y): 
            // Vai nh√¢n v·∫≠t ~ -25*s. Tay c·∫ßm s√∫ng th·∫•p h∆°n vai ch√∫t (-5*s).
            // Ng√≤i b√∫t n·∫±m gi·ªØa th√¢n b√∫t. 
            // -> Ch·ªânh v·ªÅ -32*s l√† ngay t√¢m ng√≤i.
            let bulletY = player.y - 32 * s; 

            // 2. T√≠nh kho·∫£ng c√°ch (X):
            // Tay c√°ch th√¢n kho·∫£ng 15*s.
            // Chi·ªÅu d√†i b√∫t l√† 130*s, tay c·∫ßm ·ªü v·ªã tr√≠ 75% th√¢n b√∫t (t·ª´ ƒëu√¥i l√™n).
            // => Ng√≤i b√∫t c√°ch tay c·∫ßm kho·∫£ng 55*s.
            // => T·ªïng kho·∫£ng c√°ch t·ª´ t√¢m ng∆∞·ªùi ƒë·∫øn ng√≤i b√∫t ~ 70*s.
            let offsetDir = player.facingRight ? 1 : -1;
            let bulletX = player.x + (70 * s * offsetDir);
            
            bullets.push(new Bullet(bulletX, bulletY, player.facingRight));
        }
        else {
             this.cooldown = 20; // Tay kh√¥ng
        }
    }

    draw() {
        this.updatePos();
        if (this.cooldown > 0) this.cooldown--;

        // T√≠nh k√≠ch th∆∞·ªõc ·∫£nh d·ª±a tr√™n b√°n k√≠nh m·ªõi
        // 30 * 2.3 = 69px (V·ª´a v·∫∑n v·ªõi ng√≥n tay)
        let size = this.radius * 2.3; 
        
        if (this.pressed) size *= 0.9;

        if (images["1012"] && images["1012"].complete) {
            ctx.save();
            let drawX = this.x - size / 2;
            let drawY = this.y - size / 2;

            ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;

            if (this.cooldown > 0) {
                ctx.globalAlpha = 0.5; 
            }

            ctx.drawImage(images["1012"], drawX, drawY, size, size);
            
            if (this.cooldown > 0) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
                ctx.fill();
            }

            ctx.restore();
        } 
        else {
            // V·∫Ω d·ª± ph√≤ng n·∫øu ch∆∞a c√≥ ·∫£nh
            let color = this.pressed ? "#cc0000" : "#ff3333";
            if (this.cooldown > 0) color = "#550000"; 

            drawCircle(this.x, this.y, this.radius, "rgba(255, 255, 255, 0.3)", true);
            drawCircle(this.x, this.y, this.radius - 5, color, true);
            drawCircle(this.x, this.y, this.radius - 5, "#fff", false, 2);
            drawText("ƒê√ÅNH", this.x, this.y, 14, "#fff", "center", true); // Gi·∫£m size ch·ªØ ch√∫t
        }
    }
}
// --- CLASS: N√öT L∆Ø·ªöT (DASH) ---
class DashButton {
    constructor() {
        this.radius = 12; 
        this.x = 0; this.y = 0;
        this.pressed = false;
    }

    updatePos() {
        // --- V·ªä TR√ç CHO XA V√Ä C√ÇN ƒê·ªêI ---
        
        // (SCREEN_HEIGHT) - L√™n, Xu·ªëng
        this.y = SCREEN_HEIGHT - 72; 
        
        // (SCREEN_WIDTH) - Tr√°i, Ph·∫£i
        this.x = SCREEN_WIDTH - 115; 
    }

    checkClick(x, y, player, joystickX, joystickY) {
        let dist = Math.sqrt((x - this.x)**2 + (y - this.y)**2);
        if (dist <= this.radius * 1.5) { 
            this.pressed = true;
            player.dash(joystickX, joystickY);
            setTimeout(() => this.pressed = false, 150);
            return true;
        }
        return false;
    }

    draw() {
        this.updatePos();
        
        ctx.save();
        let scale = this.pressed ? 0.9 : 1.0;
        
        // Ki·ªÉm tra ·∫£nh 1004 thay v√¨ 1016
        if (images["1004"] && images["1004"].complete) {
            let iconSize = 28 * scale; 
            
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            let img = images["1004"];
            
            // T√çNH TO√ÅN C·∫ÆT ·∫¢NH
            let sw = img.width / 2; // Chi·ªÅu r·ªông 1 frame (chia ƒë√¥i ·∫£nh)
            let sh = img.height;    // Chi·ªÅu cao
            let sx = sw;            // B·∫Øt ƒë·∫ßu t·ª´ gi·ªØa ·∫£nh (L·∫•y h√¨nh b√™n PH·∫¢I - Ch·∫°y)
            let sy = 0;

            // V·∫Ω ·∫£nh ƒë√£ c·∫Øt: (img, sx, sy, sw, sh, dx, dy, dw, dh)
            ctx.drawImage(img, sx, sy, sw, sh, this.x - iconSize/2, this.y - iconSize/2, iconSize, iconSize);

        } else {
            drawText(">>>", this.x, this.y, 16, "#fff", "center", true);
        }
        
        ctx.restore();
    }
}
// --- CLASS: N√öT NG·ªíI THI·ªÄN (ƒê√É CH·ªàNH SIZE CHU·∫®N) ---
class SitButton {
    constructor() {
        this.radius = 12; // GI·∫¢M SIZE: B·∫±ng y h·ªát n√∫t DashButton
        this.x = 0; 
        this.y = 0;
        this.pressed = false;
    }

    updatePos() {
        // V·ªã tr√≠ ƒë·ªëi x·ª©ng v·ªõi n√∫t Ch·∫°y
        // N√∫t Ch·∫°y: x = SCREEN_WIDTH - 115
        // N√∫t Ng·ªìi: x = 115
        this.x = 115; 
        
        // Ngang h√†ng tuy·ªát ƒë·ªëi v·ªõi n√∫t Ch·∫°y
        this.y = SCREEN_HEIGHT - 72; 
    }

    checkClick(x, y) {
        let dist = Math.sqrt((x - this.x)**2 + (y - this.y)**2);
        
        // Ph·∫°m vi b·∫•m gi·ªëng h·ªát n√∫t Ch·∫°y (radius * 1.5)
        if (dist <= this.radius * 1.5) { 
            this.pressed = true;
            toggleSit();
            setTimeout(() => this.pressed = false, 150);
            return true;
        }
        return false;
    }

    draw() {
        this.updatePos();
        
        ctx.save();
        let scale = this.pressed ? 0.9 : 1.0;
        
        if (player && player.isSitting) {
            ctx.shadowColor = "#00ff00"; 
            ctx.shadowBlur = 10; // Gi·∫£m ƒë·ªô nh√≤e ch√∫t cho g·ªçn
            scale = 1.1; 
        } else {
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }

        if (images["1004"] && images["1004"].complete) {
            let img = images["1004"];
            
            // GI·∫¢M SIZE ICON: T·ª´ 45 xu·ªëng 28 (B·∫±ng n√∫t Ch·∫°y)
            let iconSize = 28 * scale; 

            // C·∫Øt ·∫£nh (Gi·ªØ nguy√™n logic l·∫•y h√¨nh b√™n tr√°i)
            let sw = img.width / 2;
            let sh = img.height;
            let sx = 0; 
            let sy = 0;

            ctx.drawImage(img, sx, sy, sw, sh, this.x - iconSize/2, this.y - iconSize/2, iconSize, iconSize);

        } else {
            // V·∫Ω d·ª± ph√≤ng khi ch∆∞a load ·∫£nh
            drawCircle(this.x, this.y, this.radius, "#ffff00");
        }
        
        ctx.restore();
    }
}
// --- CLASS: PET SLIME ƒêEN (M·ªöI) ---
class PetSlime {
    constructor(owner) {
        this.owner = owner;
        this.x = owner.x;
        this.y = owner.y;
        this.image = images["1003"]; // D√πng ·∫£nh 1003
        
        // C·∫•u h√¨nh l∆∞·ªõi ·∫£nh 3 c·ªôt x 4 h√†ng (Chu·∫©n RPG Maker)
        this.spriteCols = 3; 
        this.spriteRows = 4; 
        
        this.frameW = 0;
        this.frameH = 0;
        
        this.frameX = 0;
        this.frameY = 0; // 0:Xu·ªëng, 1:Tr√°i, 2:Ph·∫£i, 3:L√™n
        
        this.gameFrame = 0;
        this.staggerFrames = 10; 
        
        this.speed = 4.0; // T·ªëc ƒë·ªô ch·∫°y theo
        this.minDist = 60; // Kho·∫£ng c√°ch d·ª´ng l·∫°i
        
        this.lastDirection = 0; 
    }

    update() {
        if (!this.owner) return;
        
        // T√≠nh l·∫°i k√≠ch th∆∞·ªõc n·∫øu ·∫£nh m·ªõi load xong
        if (this.frameW === 0 && this.image && this.image.complete) {
            this.frameW = this.image.width / this.spriteCols;
            this.frameH = this.image.height / this.spriteRows;
        }

        const dx = this.owner.x - this.x;
        const dy = this.owner.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // --- X·ª¨ L√ù DI CHUY·ªÇN ---
        if (dist > this.minDist) {
            const angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;

            // --- ƒê·ªîI L·∫†I H∆Ø·ªöNG TR√ÅI/PH·∫¢I ---
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx < 0) {
                    // Pet ƒëi sang TR√ÅI
                    this.frameY = 2;
                } else {
                    // Pet ƒëi sang PH·∫¢I
                    this.frameY = 1;
                }
            } else {
                if (dy < 0) this.frameY = 3; // L√™n (Quay l∆∞ng)
                else this.frameY = 0;        // Xu·ªëng (Ch√≠nh di·ªán)
            }
            
            this.lastDirection = this.frameY;
            this.staggerFrames = 8; // Ch·∫°y nhanh th√¨ animation nhanh
        } else {
            // ƒê·ª©ng y√™n: Quay v·ªÅ h∆∞·ªõng c≈©
            this.frameY = this.lastDirection;
            this.staggerFrames = 15; // Th·ªü ch·∫≠m
        }

        // Animation Loop
        this.gameFrame++;
        if (this.gameFrame % this.staggerFrames === 0) {
            this.frameX++;
            if (this.frameX >= this.spriteCols) this.frameX = 0;
        }
    }

    draw(ctx, camX, camY) {
        if (!this.image || !this.image.complete || this.frameW === 0) return;
        
        let drawX = this.x - camX;
        let drawY = this.y - camY;

        let sx = this.frameX * this.frameW; 
        let sy = this.frameY * this.frameH; 

        // T√≠nh hi·ªÉn th·ªã
        let displaySize = 50; 
        let ratio = this.frameW / this.frameH; 
        let renderW = displaySize; 
        let renderH = displaySize / ratio;

        // V·∫Ω B√≥ng
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath(); 
        ctx.ellipse(drawX, drawY + renderH/2 - 5, 14, 6, 0, 0, Math.PI*2); 
        ctx.fill();

        // V·∫Ω T√™n
        drawText("Slime ƒêen", drawX, drawY - renderH/2 - 10, 10, "#ff5555", "center", true);

        // V·∫Ω Slime
        ctx.drawImage(this.image, sx, sy, this.frameW, this.frameH, drawX - renderW/2, drawY - renderH/2, renderW, renderH);
    }
}

// --- CLASS: STICKMAN ---
class Stickman {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.name = "Long K·ªµ Sƒ©";
        this.speed = 3.5; // ch·∫°y b·ªô ch·∫≠m, nhanh
        this.animTimer = 0;
        this.scale = 0.6; 
        this.facingRight = true;
        this.leanAngle = 0;
        this.strideIntensity = 0;
        
        this.equippedWeapon = null; 
        
        // --- TR·∫†NG TH√ÅI T·∫§N C√îNG ---
        this.isAttacking = false;
        this.attackTimer = 0;
        
        // Stats
        this.level = 1; this.exp = 0; this.maxExp = 200;
        this.baseHp = 1000; this.maxHp = 1000; this.hp = 1000;
        this.mp = 1000; this.maxMp = 1000;
        this.stamina = 100; this.maxStamina = 100;
        this.isDashing = false;
        this.dashTimer = 0;
        this.dashVec = {x: 0, y: 0};
        this.isSitting = false;    // Tr·∫°ng th√°i ng·ªìi
        this.hasSlime = false;
        this.sitTimer = 0;         // B·ªô ƒë·∫øm th·ªùi gian ng·ªìi
    }
    dash(dx, dy) {
        // Y√™u c·∫ßu: T·ªën 10 th·ªÉ l·ª±c v√† kh√¥ng ƒëang l∆∞·ªõt
        if (this.stamina >= 10 && !this.isDashing) {
            this.stamina -= 10;
            this.isDashing = true;
            this.dashTimer = 10; // L∆∞·ªõt trong 10 frame (kho·∫£ng 0.15s)
            
            // X√°c ƒë·ªãnh h∆∞·ªõng l∆∞·ªõt
            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                this.dashVec = {x: dx, y: dy};
            } else {
                // N·∫øu ƒëang ƒë·ª©ng y√™n th√¨ l∆∞·ªõt theo h∆∞·ªõng m·∫∑t quay
                this.dashVec = {x: this.facingRight ? 1 : -1, y: 0};
            }
        }
    }
    startAttack() {
        this.isAttacking = true;
        this.attackTimer = 15; // Th·ªùi gian ƒë√¢m (Frames)
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp < 0) this.hp = 0;
        if(typeof floatingTexts !== 'undefined') {
            floatingTexts.push(new FloatingText(this.x, this.y - 60, "-" + amount, "#ff0000"));
        }
    }
    // --- H√ÄM DI CHUY·ªÇN ---
    update(dx, dy) {
        // --- LOGIC NG·ªíI THI·ªÄN ---
        if (this.isSitting) {
            // A. N·∫øu ng∆∞·ªùi ch∆°i b·∫•m n√∫t di chuy·ªÉn -> T·ª± ƒë·ªông ƒê·ª®NG D·∫¨Y
            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                this.isSitting = false;
                this.sitTimer = 0;
                
                // Reset n√∫t Ng·ªìi v·ªÅ m√†u v√†ng
                const btn = document.getElementById('sitBtn');
                if (btn) {
                    btn.style.borderColor = "#fff";
                    btn.style.color = "#FFD700";
                    btn.style.boxShadow = "0 0 5px rgba(0,0,0,0.5)";
                }
            }
            else {
                // B. Logic h·ªìi ph·ª•c khi ng·ªìi
                this.sitTimer += 1/60; 
                if (this.sitTimer >= 10) {
                    let oldHp = this.hp;
                    this.hp = Math.min(this.hp + 100, this.maxHp);
                    this.mp = Math.min(this.mp + 100, this.maxMp);
                    if (this.stamina !== undefined) this.stamina = Math.min(this.stamina + 10, this.maxStamina);
                    
                    if (this.hp > oldHp && typeof floatingTexts !== 'undefined') {
                        floatingTexts.push(new FloatingText(this.x, this.y - 60, "+100 HP", "#00ff00"));
                        floatingTexts.push(new FloatingText(this.x, this.y - 80, "+10 MP", "#00ffff"));
                    }
                    this.sitTimer = 0; 
                }
                return; // ƒêang ng·ªìi th√¨ kh√¥ng ƒëi
            }
        }
        
        // 1. X·ª¨ L√ù L∆Ø·ªöT (DASH)
        if (this.isDashing) {
            this.x += this.dashVec.x * 15;
            this.y += this.dashVec.y * 15;
            
            this.x = Math.max(20, Math.min(WORLD_WIDTH - 20, this.x));
            this.y = Math.max(20, Math.min(WORLD_HEIGHT - 20, this.y));
            
            this.dashTimer--;
            if (this.dashTimer <= 0) this.isDashing = false;
            return; 
        }

        // --- 2. LOGIC DI CHUY·ªÇN M·ªöI (C√ì VA CH·∫†M & TR∆Ø·ª¢T T∆Ø·ªúNG) ---
        let stepX = dx * this.speed;
        let stepY = dy * this.speed;

        // KI·ªÇM TRA TR·ª§C X
        if (!checkCollision(this.x + stepX, this.y)) {
            this.x += stepX; 
        } 

        // KI·ªÇM TRA TR·ª§C Y
        if (!checkCollision(this.x, this.y + stepY)) {
            this.y += stepY; 
        }

        // C·∫≠p nh·∫≠t h∆∞·ªõng m·∫∑t
        if (dx > 0.1) this.facingRight = true;
        else if (dx < -0.1) this.facingRight = false;

        // --- 3. ANIMATION ---
        let isMoving = (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1);
        let targetLean = (Math.abs(dx) > 0.1) ? dx * 12 : 0;
        this.leanAngle += (targetLean - this.leanAngle) * 0.1;
        
        let targetStride = isMoving ? 1.0 : 0.0;
        this.strideIntensity += (targetStride - this.strideIntensity) * 0.1;
        
        let animSpeed = isMoving ? 0.2 : 0.05;
        this.animTimer += animSpeed;
        
        if (this.isAttacking) {
            this.attackTimer--;
            if (this.attackTimer <= 0) this.isAttacking = false;
        }
    }

    // --- LOGIC V·∫º B√öT CH√å ---
    drawPencil(ctx, x, y, scale, type, facingRight) {
        if (!images["1007"] || !images["1007"].complete) return;
        const img = images["1007"];
        const w = 140 * scale; 
        const h = 140 * (img.height/img.width) * scale;
        
        ctx.save();
        ctx.translate(x, y); 

        if (type === "BACK") {
            // ƒêEO SAU L∆ØNG: Xoay nghi√™ng 45 ƒë·ªô
            ctx.rotate(-Math.PI / 4); 
            ctx.drawImage(img, -w/2, -h/2, w, h);
        }

        else if (type === "HAND") {
            
            if (this.isAttacking) {
                // === T·∫§N C√îNG: ƒê√ÇM CH√âO ===
                if (!facingRight) ctx.scale(-1, 1);
                ctx.rotate(0); 
                let recoil = (this.attackTimer > 10) ? 5 : 0; 
                ctx.scale(-1, 1); // L·∫≠t b√∫t theo tr·ª•c ngang
                
                // --- HI·ªÜU ·ª®NG V·ªÜT GI√ì & XUNG K√çCH ---
                ctx.save();
                // 1. ƒê·ªô m·ªù gi·∫£m d·∫ßn theo th·ªùi gian chi√™u (bi·∫øn m·∫•t khi k·∫øt th√∫c)
                let alpha = this.attackTimer / 15; 
                ctx.globalAlpha = alpha;
                ctx.lineWidth = 2 * scale;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)"; // M√†u tr·∫Øng s√°ng
                ctx.lineCap = "round";
                
                let tipX = -w * 0.9 + recoil; // V·ªã tr√≠ ƒë·∫ßu nh·ªçn c·ªßa b√∫t
                let len = 60 * scale;         // ƒê·ªô d√†i v·ªát gi√≥

                ctx.beginPath();
                // V·ªát gi·ªØa (d√†i nh·∫•t, th·∫≥ng t√¢m)
                ctx.moveTo(tipX + 15*scale, 0);
                ctx.lineTo(tipX + 15*scale + len, 0);
                
                // V·ªát tr√™n (ng·∫Øn h∆°n, l·ªách l√™n)
                ctx.moveTo(tipX + 25*scale, -8*scale);
                ctx.lineTo(tipX + 25*scale + len*0.6, -12*scale);
                
                // V·ªát d∆∞·ªõi (ng·∫Øn h∆°n, l·ªách xu·ªëng)
                ctx.moveTo(tipX + 25*scale, 8*scale);
                ctx.lineTo(tipX + 25*scale + len*0.6, 12*scale);
                ctx.stroke();
                
                // 2. V√≤ng xung k√≠ch (Ch·ªâ hi·ªán ·ªü nh·ªØng frame ƒë·∫ßu ti√™n c·ªßa c√∫ ƒë√¢m)
                if (this.attackTimer > 10) {
                     ctx.beginPath();
                     ctx.lineWidth = 3 * scale;
                     ctx.strokeStyle = `rgba(255, 255, 100, ${alpha})`; // M√†u v√†ng nh·∫°t
                     // V·∫Ω cung tr√≤n tr∆∞·ªõc m≈©i b√∫t
                     ctx.arc(tipX, 0, 20*scale, -0.6, 0.6);
                     ctx.stroke();
                }

                ctx.restore();
                // ---------------------------------------------

                // V·∫Ω ·∫£nh c√¢y b√∫t ƒë√® l√™n hi·ªáu ·ª©ng
                ctx.drawImage(img, -w * 0.9 + recoil, -h/2, w, h);

            } else {
                // CH·∫†Y KI·ªÇU NARUTO (Kh√¥ng t·∫•n c√¥ng)
                let angle = -Math.PI / 3; 
                if (facingRight) { ctx.rotate(angle); } 
                else { ctx.scale(-1, 1); ctx.rotate(angle); }
                let holdOffsetY = -h * 0.35; 
                ctx.drawImage(img, -w/2, -h/2 + holdOffsetY, w, h); 
            }
        }
        ctx.restore();
    }
    // --- H√ÄM: V·∫º TH∆Ø·ªöC K·∫∫ ---
    drawRuler(ctx, x, y, scale, type, facingRight, isMoving) {
        if (!images["1024"] || !images["1024"].complete) return;
        const img = images["1024"];
        
        const w = 140 * scale; 
        const h = 140 * (img.height/img.width) * scale;
        
        ctx.save();
        ctx.translate(x, y); // D·ªùi g·ªëc t·ªça ƒë·ªô v·ªÅ ƒë√∫ng v·ªã tr√≠ tay

        // N·∫øu quay tr√°i th√¨ l·∫≠t ng∆∞·ª£c canvas
        if (!facingRight) ctx.scale(-1, 1);

        if (type === "BACK") {
            // ƒêEO SAU L∆ØNG
            ctx.rotate(0); 
            ctx.drawImage(img, -w/2, -h/2, w, h);
        }
        else if (this.isAttacking) {
            let progress = 1 - (this.attackTimer / 20); 
            
            // G√≥c xoay: T·ª´ -120 ƒë·ªô (gi∆° cao) ch√©m xu·ªëng +45 ƒë·ªô
            let startAngle = -Math.PI / 1.5; 
            let endAngle = Math.PI / 4;
            let currentAngle = startAngle + (endAngle - startAngle) * progress;

            ctx.rotate(currentAngle);

            // V·∫Ω hi·ªáu ·ª©ng v·ªát ch√©m (m√†u tr·∫Øng m·ªù)
            if (progress > 0.2 && progress < 0.8) {
                ctx.beginPath();
                // V·∫Ω cung tr√≤n theo m≈©i th∆∞·ªõc
                ctx.arc(0, -90 * scale, w * 0.80, -0.6, 0.6, false);
                ctx.lineWidth = 15 * scale;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.stroke();
            }

            // --- T·ªåA ƒê·ªò V·∫º QUAN TR·ªåNG ƒê·ªÇ KH·ªöP TAY ---
            // -w * 0.15: D·ªùi h√¨nh l√πi l·∫°i m·ªôt ch√∫t ƒë·ªÉ c√°n th∆∞·ªõc n·∫±m ngay t√¢m xoay (0,0)
            // -h * 0.65: CƒÉn ch·ªânh chi·ªÅu d·ªçc ƒë·ªÉ th∆∞·ªõc kh√¥ng b·ªã l·ªách kh·ªèi tay
            // B·∫°n c√≥ th·ªÉ ch·ªânh s·ªë 0.15 v√† 0.65 n√†y n·∫øu v·∫´n th·∫•y ch∆∞a v·ª´a √Ω
            ctx.drawImage(img, -w * 0.3, -h * 0.65, w, h);

        } else {
            // === DI CHUY·ªÇN / ƒê·ª®NG Y√äN ===
            // Xoay th∆∞·ªõc n·∫±m ngang khi ch·∫°y
            ctx.rotate(-Math.PI + 0.45); 
            
            // V·ªã tr√≠ v·∫Ω khi c·∫ßm b√¨nh th∆∞·ªùng
            ctx.drawImage(img, -w * 0.1, -h * 0.95, w, h); 
        }
        
        ctx.restore();
    }
    // --- H√ÄM: V·∫º B√öT X√ìA (S√öNG) - ƒê√É CH·ªàNH G√ìC X√âO H∆†N ---
    drawCorrectionPen(ctx, x, y, scale, type, facingRight, isMoving) {
        if (!images["1025"] || !images["1025"].complete) return;
        const img = images["1025"];
        
        // ·∫¢nh g·ªëc: N·ª≠a tr√™n (M·ªü n·∫Øp), N·ª≠a d∆∞·ªõi (ƒê√≥ng n·∫Øp)
        const srcH = img.height / 2; 
        const w = 130 * scale; 
        const h = 130 * (srcH / img.width) * scale;

        ctx.save();
        ctx.translate(x, y);

        // --- TR∆Ø·ªúNG H·ª¢P 1: ƒêEO SAU L∆ØNG (BACK) ---
        if (type === "BACK") {
            // X·ª≠ l√Ω h∆∞·ªõng quay c·ªßa nh√¢n v·∫≠t
            if (!facingRight) ctx.scale(-1, 1);
            
            // --- ƒêI·ªÄU CH·ªàNH ƒê·ªò NGHI√äNG T·∫†I ƒê√ÇY ---
            // scale(-1, 1): L·∫≠t ·∫£nh ƒë·ªÉ n·∫Øp quay v·ªÅ ph√≠a sau g√°y
            ctx.scale(-1, 1); 
            
            // Math.PI / 4 (45 ƒë·ªô): G√≥c nghi√™ng chu·∫©n nh·∫•t (x√©o h∆°n m·ª©c 60 ƒë·ªô c≈©)
            // Gi√∫p n·∫Øp v·∫´n quay l√™n tr√™n nh∆∞ng th√¢n b√∫t n·∫±m ch√©o l∆∞ng
            ctx.rotate(Math.PI / 4); 
            
            // V·∫Ω ·∫£nh d∆∞·ªõi (ƒê√≥ng n·∫Øp)
            ctx.drawImage(img, 0, srcH, img.width, srcH, -w/2, -h/2, w, h);
        }
        
        // --- TR∆Ø·ªúNG H·ª¢P 2: C·∫¶M TAY (HAND) ---
        else if (type === "HAND") {
            // Logic c·∫ßm tay gi·ªØ nguy√™n nh∆∞ c≈© v√¨ b·∫°n ƒë√£ th·∫•y ƒë√∫ng
            if (!facingRight) {
                ctx.scale(-1, 1);
            }

            if (isMoving || this.isAttacking) {
                ctx.rotate(0); 
                ctx.scale(-1, 1); // ƒê·∫ßu nh·ªçn quay ra ngo√†i

                let recoil = (this.isAttacking && this.attackTimer > 10) ? -8 * scale : 0;
                let dx = -w * 0.75 + recoil; 
                let dy = -h * 0.65;         

                ctx.drawImage(img, 0, 0, img.width, srcH, dx, dy, w, h);
                
                // --- HI·ªÜU ·ª®NG TIA M·ª∞C B·∫ÆN RA (MUZZLE FLASH) ---
                // Ch·ªâ hi·ªán trong 3 frame ƒë·∫ßu ti√™n khi b√≥p c√≤ (t·ª´ 15 xu·ªëng 12)
                if (this.isAttacking && this.attackTimer > 12) {
                    ctx.save();
                    
                    // 1. X√°c ƒë·ªãnh to·∫° ƒë·ªô ƒë·∫ßu ng√≤i b√∫t
                    let tipX = dx + w; 
                    let tipY = dy + h * 0.35; 

                    // 2. T·∫°o hi·ªáu ·ª©ng ph√°t s√°ng (Glow) m√†u Xanh Cyan ƒë·∫∑c tr∆∞ng c·ªßa b√∫t x√≥a
                    ctx.shadowColor = "#00FFFF"; 
                    ctx.shadowBlur = 10;
                    ctx.lineCap = "round"; // ƒê·∫ßu n√©t v·∫Ω tr√≤n tr·ªãa

                    // 3. V·∫Ω 3 tia m·ª±c b·∫Øn ra (Thay v√¨ v·∫Ω h√¨nh tr√≤n)
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.95)"; // M√†u tr·∫Øng s√°ng
                    ctx.lineWidth = 3 * scale;
                    
                    ctx.beginPath();
                    
                    // Tia 1: B·∫Øn th·∫≥ng
                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(tipX + 25 * scale, tipY);

                    // Tia 2: B·∫Øn ch√©o l√™n (Ng·∫Øn h∆°n ch√∫t)
                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(tipX + 18 * scale, tipY - 6 * scale);

                    // Tia 3: B·∫Øn ch√©o xu·ªëng
                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(tipX + 18 * scale, tipY + 6 * scale);
                    
                    ctx.stroke();

                    // 4. V·∫Ω th√™m m·ªôt v√≤ng m·ªù s∆∞∆°ng (Mist) bao quanh ƒë·∫ßu s√∫ng
                    // T·∫°o c·∫£m gi√°c kh√≠ n√©n tho√°t ra
                    ctx.shadowBlur = 0; // T·∫Øt glow cho ph·∫ßn n√†y ƒë·ªÉ ko b·ªã ch√≥i
                    let grd = ctx.createRadialGradient(tipX, tipY, 2, tipX, tipY, 15 * scale);
                    grd.addColorStop(0, "rgba(255, 255, 255, 0.8)");   // T√¢m tr·∫Øng
                    grd.addColorStop(1, "rgba(0, 255, 255, 0)");       // Ngo√†i c√πng trong su·ªët
                    
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(tipX, tipY, 15 * scale, 0, Math.PI*2);
                    ctx.fill();

                    ctx.restore();
                }
            } else {
                // ƒê·ª©ng ngh·ªâ
                ctx.rotate(Math.PI / 4); 
                ctx.scale(-1, 1);       
                ctx.drawImage(img, 0, srcH, img.width, srcH, -w/2, -h/2, w, h);
            }
        }
        ctx.restore();
    }

    _drawInternal(cx, cy, s, t, facingRight, leanAngle, strideIntensity) {
        // --- [B√ìNG ƒê·ªî] ---
        ctx.save();
        let shadowY = cy + 34 * s; 
        if (this.isSitting) shadowY = cy + 25 * s;
        ctx.translate(cx, shadowY);
        ctx.scale(1, 0.4); 
        ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 0, 0, 0.15)"; ctx.fill();
        ctx.restore();

        let walkDir = facingRight ? 1 : -1;
        let color = COLORS.INK_BLACK;
        
        let isMoving = strideIntensity > 0.1; // Bi·∫øn ki·ªÉm tra ƒëang di chuy·ªÉn
        let breathY = 0;
        
        if (!isMoving && !this.isSitting && !this.isAttacking) {
            let time = Date.now() / 250; 
            breathY = Math.sin(time) * 1.5 * s; 
        }

        let runBob = (Math.sin(t)**2) * 4 * s * strideIntensity;
        let hipX = cx; let hipY = cy + runBob;
        let shoulderX = cx + leanAngle; 
        let shoulderY = cy - 25 * s + runBob + breathY;
        let headX = shoulderX + leanAngle * 0.2; let headY = shoulderY - 15 * s;

        let handLX = cx, handLY = cy, handRX = cx, handRY = cy;
        let armLen = 30 * s; 
        let legLen = 35 * s;
        let kneeDir = facingRight ? -1 : 1;

        // TR∆Ø·ªúNG H·ª¢P 1: ƒêANG NG·ªíI THI·ªÄN (Gi·ªØ nguy√™n code c≈©)
        if (this.isSitting) {
            // ... (Gi·ªØ nguy√™n ƒëo·∫°n code v·∫Ω ng·ªìi thi·ªÅn c·ªßa b·∫°n ·ªü ƒë√¢y) ...
            // Copy l·∫°i ƒëo·∫°n logic ng·ªìi thi·ªÅn c≈© v√†o ƒë√¢y
             let sitY = cy + 20 * s; 
            let sitHipX = cx;      
            let sitHipY = sitY;
            let sitShoulderX = cx;
            let sitShoulderY = sitY - 30 * s; 

            if (this.equippedWeapon === "PENCIL") {
                 this.drawPencil(ctx, sitShoulderX, sitShoulderY + 10*s, s, "BACK", facingRight);
            }
            else if (this.equippedWeapon === "RULER") {
                 this.drawRuler(ctx, sitShoulderX, sitShoulderY + 5*s, s, "BACK", facingRight, false);
            }

            drawLimb([sitHipX, sitHipY], [sitHipX - 20*s, sitHipY + 15*s], 25*s, color, 1);
            ctx.beginPath(); ctx.moveTo(sitHipX - 20*s, sitHipY + 15*s); ctx.lineTo(sitHipX, sitHipY + 25*s); ctx.stroke();
            drawLimb([sitHipX, sitHipY], [sitHipX + 20*s, sitHipY + 15*s], 25*s, color, -1);
            ctx.beginPath(); ctx.moveTo(sitHipX + 20*s, sitHipY + 15*s); ctx.lineTo(sitHipX, sitHipY + 25*s); ctx.stroke();
            drawLine(sitHipX, sitHipY, sitShoulderX, sitShoulderY, color, 3);
            drawCircle(sitShoulderX, sitShoulderY - 13*s, 10*s, color, false, 3); 
            ctx.beginPath(); ctx.moveTo(sitShoulderX, sitShoulderY); 
            ctx.quadraticCurveTo(sitShoulderX - 20*s, sitShoulderY + 5*s, sitHipX - 15*s, sitHipY + 5*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(sitShoulderX, sitShoulderY); 
            ctx.quadraticCurveTo(sitShoulderX + 20*s, sitShoulderY + 5*s, sitHipX + 15*s, sitHipY + 5*s); ctx.stroke();
             if (this.sitTimer > 0) {
                 ctx.beginPath();
                 let auraAlpha = (Math.sin(Date.now()/200) + 1) / 2 * 0.5; 
                 ctx.strokeStyle = `rgba(0, 255, 0, ${auraAlpha})`;
                 ctx.lineWidth = 2;
                 ctx.arc(sitHipX, sitHipY - 15*s, 35*s, 0, Math.PI * 2);
                 ctx.stroke();
                 ctx.lineWidth = 3; ctx.strokeStyle = color;
            }

        } else {
            // TR∆Ø·ªúNG H·ª¢P 2: ƒê·ª®NG / CH·∫†Y B√åNH TH∆Ø·ªúNG
            if (!isMoving && !this.isAttacking) {
                if (this.equippedWeapon === "PENCIL") {
                    this.drawPencil(ctx, shoulderX, shoulderY + 5*s, s, "BACK", facingRight);
                }
                else if (this.equippedWeapon === "RULER") {
                    this.drawRuler(ctx, shoulderX, shoulderY + 5*s, s, "BACK", facingRight, false);
                }
                else if (this.equippedWeapon === "CORRECTION_PEN") {
                // V·∫Ω d·∫°ng "BACK" (ƒê√≥ng n·∫Øp, ƒëeo ch√©o)
                this.drawCorrectionPen(ctx, shoulderX, shoulderY + 5*s, s, "BACK", facingRight, false);
            }
            }

            // V·∫Ω Ch√¢n & Th√¢n
            let strideW = Math.cos(t) * 16 * s * walkDir * strideIntensity;
            let lift = Math.sin(t) * 8 * s * strideIntensity;
            let footLX = cx + strideW;
            let footLY = cy + 30 * s + (strideIntensity > 0.1 ? Math.min(0, lift) : 0);
            let footRX = cx - strideW;
            let footRY = cy + 30 * s + (strideIntensity > 0.1 ? Math.min(0, -lift) : 0);
            if (strideIntensity < 0.05) {
                footLX = cx + 12 * s; footRX = cx - 12 * s;
                footLY = footRY = cy + 34 * s;
            }

            drawLimb([hipX, hipY], [footRX, footRY], legLen, color, kneeDir);
            drawLimb([hipX, hipY], [footLX, footLY], legLen, color, kneeDir);
            drawLine(hipX, hipY, shoulderX, shoulderY, color, 3);

            // --- T√çNH TO√ÅN TAY ---
            // TR∆Ø·ªúNG H·ª¢P 1: T·∫§N C√îNG B·∫∞NG B√öT CH√å (ƒê√¢m th·∫≥ng)
            if (this.equippedWeapon === "PENCIL" && this.isAttacking) {
                let angleVal = Math.PI / 4; 
                let maxReach = 50 * s; 
                let currentReach = maxReach;
                // Hi·ªáu ·ª©ng th·ª•t tay v√†o r·ªìi ƒë√¢m m·∫°nh ra
                if (this.attackTimer <= 10) currentReach = maxReach * (0.5 + 0.5 * (this.attackTimer / 10));
                
                let dx = currentReach * Math.cos(angleVal); 
                let dy = currentReach * Math.sin(angleVal); 
                
                if (facingRight) {
                    handRX = shoulderX + dx; handRY = shoulderY + dy; 
                    handLX = shoulderX - 10 * s; handLY = shoulderY + 15 * s;
                } else {
                    handRX = shoulderX - dx; handRY = shoulderY + dy;
                    handLX = shoulderX + 10 * s; handLY = shoulderY + 15 * s;
                }
            } 

            // TR∆Ø·ªúNG H·ª¢P 2: T·∫§N C√îNG B·∫∞NG TH∆Ø·ªöC K·∫∫ (Vung ƒëao v√≤ng cung)
            else if (this.equippedWeapon === "RULER" && this.isAttacking) {
                // 1. T√≠nh ti·∫øn ƒë·ªô ƒë√≤n ƒë√°nh (t·ª´ 0 ƒë·∫øn 1)
                // attackTimer ch·∫°y t·ª´ 20 v·ªÅ 0.
                let progress = 1 - (this.attackTimer / 20);

                // 2. G√≥c vung tay: Ph·∫£i kh·ªõp v·ªõi g√≥c quay c·ªßa c√¢y th∆∞·ªõc
                // B·∫Øt ƒë·∫ßu t·ª´ ph√≠a sau tr√™n cao (-120 ƒë·ªô) ch√©m xu·ªëng ph√≠a tr∆∞·ªõc (+45 ƒë·ªô)
                let startAngle = -Math.PI / 1.5; 
                let endAngle = Math.PI / 4;
                
                // T√≠nh g√≥c hi·ªán t·∫°i d·ª±a theo ti·∫øn ƒë·ªô
                let curAngle = startAngle + (endAngle - startAngle) * progress;

                // 3. ƒê·ªô d√†i s·∫£i tay (V∆∞∆°n ra xa ƒë·ªÉ ch√©m)
                let reach = 45 * s; 

                // 4. T√≠nh t·ªça ƒë·ªô tay ƒë√≤n (D√πng sin/cos ƒë·ªÉ tay xoay tr√≤n quanh vai)
                let dx = Math.cos(curAngle) * reach;
                let dy = Math.sin(curAngle) * reach;

                if (facingRight) {
                    handRX = shoulderX + dx; 
                    handRY = shoulderY + dy;
                    
                    // Tay tr√°i (tay kh√¥ng) vung nh·∫π ra sau gi·ªØ thƒÉng b·∫±ng
                    handLX = shoulderX - 20 * s; 
                    handLY = shoulderY + 20 * s;
                } else {
                    // N·∫øu quay tr√°i, l·∫≠t ng∆∞·ª£c tr·ª•c X
                    handRX = shoulderX - dx; 
                    handRY = shoulderY + dy; 
                    
                    handLX = shoulderX + 20 * s;
                    handLY = shoulderY + 20 * s;
                }
            }

            // TR∆Ø·ªúNG H·ª¢P 3: ƒêI B·ªò / CH·∫†Y / ƒê·ª®NG Y√äN (M·∫∑c ƒë·ªãnh)
            else {
                let armSwing = Math.cos(t) * 15 * s * strideIntensity;
                let forwardOffset = 5 * s * walkDir * strideIntensity;
                
                handLX = shoulderX + armSwing + forwardOffset;
                handLY = shoulderY + 20 * s;
                handRX = shoulderX - armSwing + forwardOffset;
                handRY = shoulderY + 20 * s;

                // Logic c·∫ßm B√öT CH√å khi ch·∫°y (Ki·ªÉu Naruto)
                if (this.equippedWeapon === "PENCIL" && isMoving) {
                    let reachBack = 30 * s; let heightBack = 5 * s;
                    if (facingRight) {
                        handRX = shoulderX - reachBack; handRY = shoulderY + heightBack;
                        handLX = shoulderX + 20 * s; 
                    } else {
                        handRX = shoulderX + reachBack; handRY = shoulderY + heightBack;
                        handLX = shoulderX - 20 * s;
                    }
                } 
                // Logic c·∫ßm TH∆Ø·ªöC K·∫∫ khi ch·∫°y (K√©o l√™ d∆∞·ªõi ƒë·∫•t)
                else if (this.equippedWeapon === "RULER" && isMoving) {
                    let dragReachBack = 35 * s; 
                    let dragHeightLow = 20 * s; 
                    
                    if (facingRight) {
                        handRX = shoulderX - dragReachBack; 
                        handRY = shoulderY + dragHeightLow; 
                        handLX = shoulderX + 20 * s; 
                    } else {
                        handRX = shoulderX + dragReachBack;
                        handRY = shoulderY + dragHeightLow;
                        handLX = shoulderX - 20 * s;
                    }
                }
                else if (this.equippedWeapon === "CORRECTION_PEN" && (isMoving || this.isAttacking)) {
                    // T∆∞ th·∫ø v√°c vai:
                    // Tay ph·∫£i (RX): ƒê·∫∑t g·∫ßn vai ƒë·ªÉ b√≥p c√≤.
                    // Tay tr√°i (LX): ƒê·∫∑t xa h∆°n ƒë·ªÉ ƒë·ª° n√≤ng s√∫ng.
                    if (facingRight) {
                        handRX = shoulderX + 15 * s;  // Tay c√≤ (G·∫ßn th√¢n)
                        handRY = shoulderY - 5 * s;   // Cao ngang vai
                        
                        handLX = shoulderX + 50 * s;  // Tay ƒë·ª° (Xa th√¢n)
                        handLY = shoulderY - 8 * s;   // H∆°i cao h∆°n tay c√≤ t√≠
                    } else {
                        // L·∫≠t ng∆∞·ª£c l·∫°i cho b√™n tr√°i
                        handRX = shoulderX - 15 * s; 
                        handRY = shoulderY - 5 * s;
                        
                        handLX = shoulderX - 50 * s;
                        handLY = shoulderY - 8 * s;
                    }
                }
                else if (!isMoving) {
                    handLX = shoulderX + 13 * s; handRX = shoulderX - 13 * s;
                    handLY = handRY = shoulderY + 28 * s;
                }
            }

            drawLimb([shoulderX, shoulderY], [handRX, handRY], armLen, color, -kneeDir); 
            drawLimb([shoulderX, shoulderY], [handLX, handLY], armLen, color, -kneeDir); 
            drawCircle(headX, headY, 10 * s, color, false, 3); 
        }

        // --- V·∫º V≈® KH√ç TR√äN TAY ---
        if (!this.isSitting) {
            // Ch·ªâ v·∫Ω khi ƒëang Di chuy·ªÉn ho·∫∑c ƒëang T·∫•n c√¥ng
            if (isMoving || this.isAttacking) {
                
                // 1. N·∫øu l√† B√öT CH√å
                if (this.equippedWeapon === "PENCIL") {
                    this.drawPencil(ctx, handRX, handRY, s, "HAND", facingRight);
                }
                
                // 2. N·∫øu l√† TH∆Ø·ªöC K·∫∫
                else if (this.equippedWeapon === "RULER") {
                    this.drawRuler(ctx, handRX, handRY, s, "HAND", facingRight, isMoving);
                }
                
                // >>> 3. S√öNG B√öT X√ìA
                else if (this.equippedWeapon === "CORRECTION_PEN") {
                    // Tham s·ªë cu·ªëi c√πng l√† 'true' ƒë·ªÉ k√≠ch ho·∫°t ch·∫ø ƒë·ªô b·∫Øn/v√°c vai
                    this.drawCorrectionPen(ctx, handRX, handRY, s, "HAND", facingRight, true);
                }
            }
        }
    }

    draw(camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;
        this._drawInternal(cx, cy, this.scale, this.animTimer, this.facingRight, this.leanAngle, this.strideIntensity);
    }

    drawUIPreview(x, y, scale) {
        let t = Date.now() / 500;
        this._drawInternal(x, y, scale, t, true, 0, 0);
    }
    
    // 1. H√†m ƒë√≥ng g√≥i d·ªØ li·ªáu ƒë·ªÉ L∆∞u game
    toDict() {
        return {
            name: this.name,
            x: this.x, 
            y: this.y,
            level: this.level,
            exp: this.exp,
            hp: this.hp,
            mp: this.mp,
            stamina: this.stamina,
            equippedWeapon: this.equippedWeapon,
            
            hasSlime: this.hasSlime
        };
    }

    // 2. H√†m ƒë·ªçc d·ªØ li·ªáu ƒë·ªÉ T·∫£i game (Load)
    fromDict(data) {
        if (!data) return;
        if (data.name) this.name = data.name;
        // Ch·ªâ load v·ªã tr√≠ n·∫øu h·ª£p l·ªá
        if (data.x !== undefined && !isNaN(data.x)) this.x = data.x;
        if (data.y !== undefined && !isNaN(data.y)) this.y = data.y;
        
        if (data.level) this.level = data.level;
        if (data.exp !== undefined) this.exp = data.exp;
        
        // C·∫≠p nh·∫≠t ch·ªâ s·ªë t·ªëi ƒëa theo Level
        this.maxHp = 1000 + (this.level - 1) * 100;
        this.maxMp = 1000 + (this.level - 1) * 50;
        this.maxExp = 200 * this.level;

        // N·∫°p HP/MP hi·ªán t·∫°i
        if (data.hp !== undefined) this.hp = Math.min(data.hp, this.maxHp);
        else this.hp = this.maxHp;

        if (data.mp !== undefined) this.mp = Math.min(data.mp, this.maxMp);
        else this.mp = this.maxMp;

        if (data.stamina !== undefined) this.stamina = data.stamina;
        if (data.equippedWeapon !== undefined) this.equippedWeapon = data.equippedWeapon;
        if (data.hasSlime !== undefined) this.hasSlime = data.hasSlime;
    }
}
// --- CLASS: INVENTORY PANEL ---
class InventoryPanel {
    constructor() {
        this.visible = false;
        this.slotSize = 50; 
        this.gap = 6;
        this.cols = 6;
        this.rows = 6;
        this.w = 360; this.h = 450;
        this.x = 0; this.y = 0;
        
        this.items = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
        this.gold = 9999;
        this.selectedSlot = null;
        
        this._generateFakeItems();
        
        this.rect = {x:0, y:0, w:0, h:0};
        this.closeBtnRect = {x:0, y:0, w:0, h:0};
        this.useBtnRect = {x:0, y:0, w:0, h:0};
    }

    _generateFakeItems() {
        this.items[0][0] = { type: "PENCIL", count: 1, img: "1007", name: "B√∫t Ch√¨ Th·∫ßn" };
        this.items[0][1] = { type: "HP_POTION", count: 10, img: "1013", name: "B√¨nh M√°u" };
        this.items[0][2] = { type: "MP_POTION", count: 10, img: "1013", name: "B√¨nh Mana" };
        this.items[0][3] = { type: "DUAL_POTION", count: 5, img: "1013", name: "B√¨nh H·ªón H·ª£p" };
        this.items[0][4] = { type: "STAMINA_POTION", count: 5, img: "1013", name: "B√¨nh Th·ªÉ L·ª±c" };
    }

    addItem(type, count, img) {
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                if (this.items[r][c] === null) {
                    this.items[r][c] = { type: type, count: count, img: img };
                    return true; 
                }
            }
        }
        console.log("H√†nh trang ƒë·∫ßy!");
        return false; 
    }

    toDict() { return {items: this.items, gold: this.gold}; }
    fromDict(data) {
        if (data.gold !== undefined) this.gold = data.gold;
        if (data.items && Array.isArray(data.items)) {
            let newItems = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
            for (let r = 0; r < this.rows; r++) {
                if (!data.items[r]) continue; 
                for (let c = 0; c < this.cols; c++) {
                    let item = data.items[r][c];
                    if (item) {
                        if (item.type === "SWORD" || item.type === "SHIELD" || item.type === "BOOK") {
                            item.type = "PENCIL"; item.img = "1007"; item.name = "B√∫t Ch√¨ Th·∫ßn";
                        }
                        else if (item.type === "HP") { item.type = "HP_POTION"; item.img = "1008"; item.name = "B√¨nh M√°u"; } 
                        else if (item.type === "MP") { item.type = "MP_POTION"; item.img = "1009"; item.name = "B√¨nh Mana"; }
                        if (!item.img) {
                            if (item.type === "PENCIL") item.img = "1007";
                            else if (item.type === "HP_POTION") item.img = "1008";
                            else if (item.type === "MP_POTION") item.img = "1009";
                            else item.img = "1010"; 
                        }
                        newItems[r][c] = item;
                    } 
                }
            }
            this.items = newItems;
        }
    }

    toggle() { 
        this.visible = !this.visible; 
        this.selectedSlot = null;
        if(this.visible) this.updatePos();
    }

    updatePos() {
        this.w = Math.min(400, SCREEN_WIDTH - 40);
        this.slotSize = Math.floor((this.w - 50) / 6);
        this.x = (SCREEN_WIDTH - this.w) / 2;
        this.y = (SCREEN_HEIGHT - this.h) / 2;
        this.rect = {x: this.x, y: this.y, w: this.w, h: this.h};
        this.closeBtnRect = {x: this.x + this.w - 30, y: this.y + 8, w: 22, h: 22};
        
        // --- [CH·ªàNH S·ª¨A] N√öT S·ª¨ D·ª§NG NH·ªé L·∫†I & QUA PH·∫¢I ---
        let btnW = 100; // Gi·∫£m chi·ªÅu r·ªông (c≈© l√† 160)
        let btnH = 35;  // Gi·∫£m chi·ªÅu cao (c≈© l√† 40)
        this.useBtnRect = {
            x: this.x + this.w - btnW - 25, // CƒÉn ph·∫£i, c√°ch l·ªÅ 25px
            y: this.y + this.h - 55,        // Ngang h√†ng v·ªõi ti·ªÅn
            w: btnW, h: btnH
        };
    }

    checkClick(mx, my) {
        if (!this.visible) return false;
        
        if (mx >= this.closeBtnRect.x && mx <= this.closeBtnRect.x + this.closeBtnRect.w &&
            my >= this.closeBtnRect.y && my <= this.closeBtnRect.y + this.closeBtnRect.h) {
            this.visible = false;
            return true;
        }

        if (this.selectedSlot) {
            let item = this.items[this.selectedSlot.r][this.selectedSlot.c];
            if (item && mx >= this.useBtnRect.x && mx <= this.useBtnRect.x + this.useBtnRect.w &&
                my >= this.useBtnRect.y && my <= this.useBtnRect.y + this.useBtnRect.h) {
                
                if (item.type === "PENCIL" || item.type === "RULER" || item.type === "CORRECTION_PEN") {
                    if (player.equippedWeapon) {
                        let oldImg = "1007"; 
                        if (player.equippedWeapon === "RULER") oldImg = "1024";
                        if (player.equippedWeapon === "CORRECTION_PEN") oldImg = "1025";
                        this.addItem(player.equippedWeapon, 1, oldImg);
                    }
                    player.equippedWeapon = item.type;
                    if(typeof floatingTexts !== 'undefined') floatingTexts.push(new FloatingText(player.x, player.y - 80, "Trang b·ªã!", "#ffff00"));
                    this.items[this.selectedSlot.r][this.selectedSlot.c] = null;
                    this.selectedSlot = null;
                    saveGame(player, inventory);
                    return true;
                }
                else if (item.type === "HP_POTION") {
                    player.hp = player.maxHp; 
                    if(typeof floatingTexts !== 'undefined') floatingTexts.push(new FloatingText(player.x, player.y - 80, "H·ªìi M√°u!", "#32c832"));
                    item.count--; 
                }
                else if (item.type === "MP_POTION") {
                    player.mp = player.maxMp; 
                    if(typeof floatingTexts !== 'undefined') floatingTexts.push(new FloatingText(player.x, player.y - 80, "H·ªìi Mana!", "#3232c8"));
                    item.count--;
                }
                else if (item.type === "DUAL_POTION") {
                    player.hp = player.maxHp; player.mp = player.maxMp;
                    if(typeof floatingTexts !== 'undefined') floatingTexts.push(new FloatingText(player.x, player.y - 80, "Ph·ª•c H·ªìi!", "#ffff00"));
                    item.count--;
                }
                else if (item.type === "STAMINA_POTION") {
                    player.stamina = player.maxStamina;
                    if(typeof floatingTexts !== 'undefined') floatingTexts.push(new FloatingText(player.x, player.y - 80, "Sung S·ª©c!", "#00ffff"));
                    item.count--;
                }

                if (item.type !== "PENCIL" && item.count <= 0) {
                    this.items[this.selectedSlot.r][this.selectedSlot.c] = null;
                    this.selectedSlot = null;
                }
                saveGame(player, inventory); 
                return true;
            }
        }
        
        let gridW = this.cols * this.slotSize + (this.cols - 1) * this.gap;
        let startX = this.x + (this.w - gridW) / 2;
        let startY = this.y + 55;

        for (let r=0; r<this.rows; r++) {
            for (let c=0; c<this.cols; c++) {
                let ox = startX + c * (this.slotSize + this.gap);
                let oy = startY + r * (this.slotSize + this.gap);
                if (mx >= ox && mx <= ox + this.slotSize && my >= oy && my <= oy + this.slotSize) {
                    let item = this.items[r][c];
                    if (item) { this.selectedSlot = {r: r, c: c}; } 
                    else { this.selectedSlot = null; }
                    return true;
                }
            }
        }
        if (mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h) return true;
        return false;
    }

    drawItemIcon(x, y, size, itemData) {
        if (!itemData) return;
        if ((itemData.type === "PENCIL" || itemData.type === "RULER" || itemData.type === "CORRECTION_PEN") && images[itemData.img] && images[itemData.img].complete) {
            let img = images[itemData.img];
            ctx.save();
            ctx.beginPath(); ctx.rect(x, y, size, size); ctx.clip();
            ctx.translate(x + size / 2, y + size / 2); 

            if (itemData.type === "CORRECTION_PEN") {
                ctx.rotate(-Math.PI / 4);
                let halfH = img.height / 2;
                let drawW = size * 0.85; 
                let drawH = drawW * (halfH / img.width);
                ctx.drawImage(img, 0, halfH, img.width, halfH, -drawW/2, -drawH/2, drawW, drawH);
            } else {
                if (itemData.type === "RULER") ctx.rotate(0);
                else ctx.rotate(-Math.PI / 4); 
                let drawW = size * 0.85; 
                let drawH = drawW * (img.height / img.width);
                ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowBlur = 5;
                ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
            }
            ctx.restore();
        } 
        else if (["HP_POTION", "MP_POTION", "DUAL_POTION", "STAMINA_POTION"].includes(itemData.type) && images["1013"] && images["1013"].complete) {
            let img = images["1013"];
            let sw = img.width / 2; let sh = img.height / 2;
            let sx = 0, sy = 0;
            if (itemData.type === "HP_POTION")      { sx = 0; sy = 0; }
            else if (itemData.type === "MP_POTION") { sx = sw; sy = 0; }
            else if (itemData.type === "DUAL_POTION"){ sx = 0; sy = sh; }
            else if (itemData.type === "STAMINA_POTION") { sx = sw; sy = sh; }
            ctx.save();
            let pad = 6; let drawSize = size - pad * 2; 
            ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 4;
            ctx.drawImage(img, sx, sy, sw, sh, x + pad, y + pad, drawSize, drawSize);
            ctx.restore();
        }
        else if (itemData.img && images[itemData.img] && images[itemData.img].complete) {
            let img = images[itemData.img];
            let padding = 6;
            let availSize = size - padding * 2;
            let ratio = Math.min(availSize / img.width, availSize / img.height);
            let w = img.width * ratio; let h = img.height * ratio;
            ctx.save();
            ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 4;
            ctx.drawImage(img, x + (size - w) / 2, y + (size - h) / 2, w, h);
            ctx.restore();
        } 
        else { drawText("?", x + size/2, y + size/2, 14, "#fff", "center"); }

        if (itemData.count > 1) {
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.beginPath(); ctx.arc(x + size - 10, y + size - 10, 8, 0, Math.PI*2); ctx.fill();
            drawText(itemData.count, x + size - 10, y + size - 9, 11, "#fff", "center", true);
        }
    }

    draw() {
        if (!this.visible) return;
        this.updatePos();

        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        drawRect(this.x, this.y, this.w, this.h, COLORS.THEME_JADE_BG, true, 8);
        drawRect(this.x, this.y, this.w, this.h, "#0a1e23", false, 8, 4);

        let headerH = 40;
        drawRect(this.x, this.y, this.w, headerH, "#234b50", true, 8); 
        drawLine(this.x, this.y + headerH, this.x + this.w, this.y + headerH, "#0a1e1e");
        drawText("H√ÄNH TRANG", this.x + this.w/2, this.y + 20, 18, COLORS.THEME_TEXT_WHITE, "center");

        drawRect(this.closeBtnRect.x, this.closeBtnRect.y, this.closeBtnRect.w, this.closeBtnRect.h, "#962828", true, 4);
        drawText("X", this.closeBtnRect.x + 11, this.closeBtnRect.y + 11, 14, "#fff", "center");

        let gridW = this.cols * this.slotSize + (this.cols - 1) * this.gap;
        let startX = this.x + (this.w - gridW) / 2;
        let startY = this.y + 55;

        for (let r=0; r<this.rows; r++) {
            for (let c=0; c<this.cols; c++) {
                let ox = startX + c * (this.slotSize + this.gap);
                let oy = startY + r * (this.slotSize + this.gap);
                
                drawRect(ox, oy, this.slotSize, this.slotSize, COLORS.THEME_SLOT_BG);
                drawRect(ox, oy, this.slotSize, this.slotSize, COLORS.THEME_SLOT_BORDER, false);
                
                if (this.items[r][c]) {
                    this.drawItemIcon(ox, oy, this.slotSize, this.items[r][c]);
                }

                if (this.selectedSlot && this.selectedSlot.r === r && this.selectedSlot.c === c) {
                    drawRect(ox-2, oy-2, this.slotSize+4, this.slotSize+4, "yellow", false, 2, 3);
                }
            }
        }
        
        // --- [CH·ªàNH S·ª¨A] N√∫t S·ª¨ D·ª§NG: ƒê√£ d·ªùi qua ph·∫£i, b·ªè else (x√≥a ch·ªØ) ---
        if (this.selectedSlot) {
            let btn = this.useBtnRect;
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 10;
            drawRect(btn.x, btn.y, btn.w, btn.h, COLORS.BTN_USE_BG, true, 8);
            drawRect(btn.x, btn.y, btn.w, btn.h, COLORS.BTN_USE_BORDER, false, 8, 2);
            ctx.shadowBlur = 0;
            drawText("S·ª¨ D·ª§NG", btn.x + btn.w/2, btn.y + btn.h/2, 14, COLORS.BTN_USE_TEXT, "center", true);
        } 
        // ƒê√É X√ìA PH·∫¶N ELSE: "Ch·ªçn v·∫≠t ph·∫©m ƒë·ªÉ xem"
        
        // --- V·ªä TR√ç TI·ªÄN (Gi·ªØ nguy√™n b√™n tr√°i) ---
        let moneyX = this.x + 25; 
        let moneyY = this.y + this.h - 55; 
        let moneyW = 100;
        let moneyH = 32;

        drawRect(moneyX, moneyY, moneyW, moneyH, "rgba(0, 0, 0, 0.6)", true, 6); 
        drawRect(moneyX, moneyY, moneyW, moneyH, "#ffd700", false, 6);            

        ctx.save();
        ctx.shadowColor = "black"; ctx.shadowBlur = 2;
        drawText(`${this.gold} ü•ú`, moneyX + moneyW/2, moneyY + moneyH/2 + 1, 15, "#ffd700", "center", true);
        ctx.restore();
    }
}
// --- CLASS: CHARACTER PANEL ---
class CharacterPanel {
    constructor() {
        this.visible = false;
        this.w = 360; this.h = 450; // TƒÉng chi·ªÅu r·ªông nh·∫π ƒë·ªÉ tho√°ng h∆°n
        this.x = 0; this.y = 0;
        
        // 0: Trang b·ªã (Equip), 1: Th√¥ng tin (Stats)
        this.activeTab = 0; 
        
        this.rect = {x:0, y:0, w:0, h:0};
        this.closeBtn = {x:0, y:0, w:22, h:22};
        
        // Rects cho 2 tab
        this.tabEquipRect = {x:0, y:0, w:0, h:0};
        this.tabInfoRect = {x:0, y:0, w:0, h:0};

        // 0: ƒê·∫ßu, 1: √Åo, 2: Qu·∫ßn, 3: Nh·∫´n, 4: V≈© kh√≠
        this.selectedEquipSlot = null; 
        this.unequipBtnRect = {x:0, y:0, w:0, h:0};
    }

    toggle() { 
        this.visible = !this.visible; 
        this.selectedEquipSlot = null; 
        // Reset v·ªÅ tab trang b·ªã khi m·ªü l·∫°i
        if(this.visible) {
            this.activeTab = 0;
            this.updatePos(); 
        }
    }

    updatePos() {
        this.w = Math.min(420, SCREEN_WIDTH - 40);
        this.x = (SCREEN_WIDTH - this.w) / 2;
        this.y = (SCREEN_HEIGHT - this.h) / 2;
        this.rect = {x:this.x, y:this.y, w:this.w, h:this.h};
        this.closeBtn = {x:this.x + this.w - 30, y:this.y + 8, w:22, h:22};

        // T√≠nh to√°n v·ªã tr√≠ 2 Tab
        let headerH = 40;
        let tabW = (this.w - 80) / 2; // Tr·ª´ kho·∫£ng tr·ªëng cho n√∫t close
        this.tabEquipRect = {x: this.x + 10, y: this.y + 5, w: tabW, h: headerH - 5};
        this.tabInfoRect = {x: this.x + 10 + tabW + 5, y: this.y + 5, w: tabW, h: headerH - 5};

        // V·ªã tr√≠ n√∫t G·ª° b·ªè (Ch·ªâ d√πng ·ªü tab Trang b·ªã)
        let btnW = 160; let btnH = 40;
        this.unequipBtnRect = {
            x: this.x + (this.w - btnW)/2,
            y: this.y + this.h - 60,
            w: btnW, h: btnH
        };
    }

    checkClick(mx, my) {
        if (!this.visible) return false;
        
        // 1. Click n√∫t ƒê√≥ng (∆Øu ti√™n cao nh·∫•t)
        if (mx >= this.closeBtn.x && mx <= this.closeBtn.x + this.closeBtn.w &&
            my >= this.closeBtn.y && my <= this.closeBtn.y + this.closeBtn.h) {
            this.visible = false; return true;
        }

        // 2. Click chuy·ªÉn Tab
        if (mx >= this.tabEquipRect.x && mx <= this.tabEquipRect.x + this.tabEquipRect.w &&
            my >= this.tabEquipRect.y && my <= this.tabEquipRect.y + this.tabEquipRect.h) {
            this.activeTab = 0; // Chuy·ªÉn sang Trang b·ªã
            this.selectedEquipSlot = null;
            return true;
        }
        if (mx >= this.tabInfoRect.x && mx <= this.tabInfoRect.x + this.tabInfoRect.w &&
            my >= this.tabInfoRect.y && my <= this.tabInfoRect.y + this.tabInfoRect.h) {
            this.activeTab = 1; // Chuy·ªÉn sang Th√¥ng tin
            return true;
        }

        // 3. X·ª≠ l√Ω Logic ri√™ng t·ª´ng Tab
        if (this.activeTab === 0) {
            // --- LOGIC TAB TRANG B·ªä ---
            // N√∫t G·ª† B·ªé
            if (this.selectedEquipSlot !== null) {
                let uBtn = this.unequipBtnRect;
                // Ki·ªÉm tra xem chu·ªôt c√≥ click tr√∫ng n√∫t G·ª° B·ªè kh√¥ng
                if (mx >= uBtn.x && mx <= uBtn.x + uBtn.w && my >= uBtn.y && my <= uBtn.y + uBtn.h) {
                    
                    // Ki·ªÉm tra xem c√≥ ƒëang ch·ªçn slot V≈© kh√≠ (index 4) v√† nh√¢n v·∫≠t c√≥ ƒëang c·∫ßm v≈© kh√≠ kh√¥ng
                    if (this.selectedEquipSlot === 4 && player.equippedWeapon) {
                        
                        // --- X√ÅC ƒê·ªäNH ·∫¢NH ƒê·ªÇ TR·∫¢ V·ªÄ T√öI ---
                        let imgID = "1007"; // M·∫∑c ƒë·ªãnh: B√∫t Ch√¨
                        if (player.equippedWeapon === "RULER") imgID = "1024";
                        if (player.equippedWeapon === "CORRECTION_PEN") imgID = "1025"; // <--- QUAN TR·ªåNG: Tr·∫£ v·ªÅ ·∫£nh S√∫ng
                        
                        // Th·ª≠ th√™m v√†o h√†nh trang
                        let added = inventory.addItem(player.equippedWeapon, 1, imgID);
                        
                        if (added) {
                            // N·∫øu th√™m th√†nh c√¥ng -> X√≥a v≈© kh√≠ tr√™n ng∆∞·ªùi
                            player.equippedWeapon = null;
                            this.selectedEquipSlot = null; 
                            
                            // L∆∞u game ngay l·∫≠p t·ª©c
                            saveGame(player, inventory);
                        } else {
                            // N·∫øu t√∫i ƒë·∫ßy -> Th√¥ng b√°o
                            alert("H√†nh trang ƒë√£ ƒë·∫ßy! Kh√¥ng th·ªÉ g·ª° b·ªè v≈© kh√≠.");
                        }
                    }
                    return true;
                }
            }

            // Click v√†o √¥ trang b·ªã
            let slotSize = 42; let gap = 12;
            let startX = this.x + 30; 
            let startY = this.y + 70;
            
            for (let i=0; i<5; i++) {
                let sy = startY + i * (slotSize + gap);
                if (mx >= startX && mx <= startX + slotSize && my >= sy && my <= sy + slotSize) {
                    let hasItem = false;
                    if (i === 4 && player.equippedWeapon) hasItem = true;
                    
                    if (hasItem) {
                        this.selectedEquipSlot = i;
                    } else {
                        this.selectedEquipSlot = null;
                    }
                    return true;
                }
            }
        } else {
            // --- LOGIC TAB TH√îNG TIN ---
            // Hi·ªán t·∫°i tab th√¥ng tin ch·ªâ xem, ch∆∞a c√≥ n√∫t b·∫•m t∆∞∆°ng t√°c
        }

        // Ch·∫∑n click xuy√™n qua b·∫£ng
        if (mx >= this.rect.x && mx <= this.rect.x + this.rect.w && my >= this.rect.y && my <= this.rect.y + this.rect.h) return true;
        return false;
    }

    draw(playerRef) {
        if (!this.visible) return;
        this.updatePos();

        // N·ªÅn m·ªù to√†n m√†n h√¨nh
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Khung b·∫£ng ch√≠nh
        drawRect(this.x, this.y, this.w, this.h, COLORS.THEME_JADE_BG, true, 5);
        drawRect(this.x, this.y, this.w, this.h, "#0a1e23", false, 0, 4);

        // --- V·∫º HEADER (TABS) ---
        let t1 = this.tabEquipRect;
        let t2 = this.tabInfoRect;

        // V·∫Ω n·ªÅn Tab 1 (Trang b·ªã)
        let bg1 = this.activeTab === 0 ? COLORS.THEME_JADE_BORDER : "#0f282d";
        let txt1 = this.activeTab === 0 ? "#fff" : "#64828c";
        drawRect(t1.x, t1.y, t1.w, t1.h, bg1, true, 5);
        drawText("TRANG B·ªä", t1.x + t1.w/2, t1.y + t1.h/2, 14, txt1, "center", true);

        // V·∫Ω n·ªÅn Tab 2 (Th√¥ng tin)
        let bg2 = this.activeTab === 1 ? COLORS.THEME_JADE_BORDER : "#0f282d";
        let txt2 = this.activeTab === 1 ? "#fff" : "#64828c";
        drawRect(t2.x, t2.y, t2.w, t2.h, bg2, true, 5);
        drawText("TH√îNG TIN", t2.x + t2.w/2, t2.y + t2.h/2, 14, txt2, "center", true);

        // ƒê∆∞·ªùng k·∫ª ngang d∆∞·ªõi header
        drawLine(this.x, this.y + 45, this.x + this.w, this.y + 45, "#0a1e1e");

        // N√∫t Close
        drawRect(this.closeBtn.x, this.closeBtn.y, this.closeBtn.w, this.closeBtn.h, "#962828", true, 2);
        drawText("X", this.closeBtn.x + 11, this.closeBtn.y + 11, 14, "#fff", "center");


        // --- N·ªòI DUNG ---
        if (this.activeTab === 0) {
            this.drawEquipTab(playerRef);
        } else {
            this.drawInfoTab(playerRef);
        }
    }

    // --- VIEW 1: TRANG B·ªä ---
    drawEquipTab(playerRef) {
        let slotSize = 42;
        let gap = 12;
        let startX = this.x + 30; 
        let startY = this.y + 70;
        
        let names = ["ƒê·∫ßu", "√Åo", "Qu·∫ßn", "Nh·∫´n", "V≈© Kh√≠"];
            
        for (let i=0; i<5; i++) {
            let sy = startY + i * (slotSize + gap);
            
            // V·∫Ω n·ªÅn √¥
            drawRect(startX, sy, slotSize, slotSize, COLORS.THEME_SLOT_BG);
            drawRect(startX, sy, slotSize, slotSize, COLORS.THEME_SLOT_BORDER, false);

            let hasItem = false;
            // Ki·ªÉm tra xem √¥ th·ª© 5 (index 4) c√≥ v≈© kh√≠ kh√¥ng
            if (i === 4 && playerRef.equippedWeapon) hasItem = true;

            if (hasItem) {
                // 1. C·∫•u h√¨nh m·∫∑c ƒë·ªãnh (B√∫t Ch√¨)
                let imgID = "1007"; 
                let rotation = -Math.PI / 4; 

                // 2. Ki·ªÉm tra lo·∫°i v≈© kh√≠ ƒë·ªÉ ƒë·ªïi ·∫£nh
                if (playerRef.equippedWeapon === "RULER") {
                    imgID = "1024"; rotation = 0;
                }
                else if (playerRef.equippedWeapon === "CORRECTION_PEN") {
                    imgID = "1025"; rotation = 0; // S√∫ng B√∫t X√≥a: D√πng ·∫£nh 1025, Kh√¥ng xoay
                }

                if (i === 4 && images[imgID] && images[imgID].complete) {
                    let img = images[imgID];
                    ctx.save();
                    
                    // T·∫°o khung c·∫Øt (Clip) ƒë·ªÉ h√¨nh kh√¥ng b·ªã lem ra ngo√†i √¥
                    ctx.beginPath(); ctx.rect(startX, sy, slotSize, slotSize); ctx.clip();
                    ctx.translate(startX + slotSize/2, sy + slotSize/2);
                    
                    // --- V·∫º S√öNG B√öT X√ìA (C·∫ÆT ·∫¢NH D∆Ø·ªöI & XOAY) ---
                    if (playerRef.equippedWeapon === "CORRECTION_PEN") {
                        ctx.rotate(-Math.PI / 4); // Xoay -45 ƒë·ªô
                        
                        // Ch·ªâ l·∫•y n·ª≠a D∆Ø·ªöI c·ªßa ·∫£nh (Ph·∫ßn ƒë√≥ng n·∫Øp)
                        let halfH = img.height / 2;
                        let drawW = slotSize * 0.85;
                        let drawH = drawW * (halfH / img.width);
                        
                        // V·∫Ω ·∫£nh: img, sx=0, sy=halfH (n·ª≠a d∆∞·ªõi), sw, sh...
                        ctx.drawImage(img, 0, halfH, img.width, halfH, -drawW/2, -drawH/2, drawW, drawH);
                    } 
                    // --- V·∫º C√ÅC V≈® KH√ç KH√ÅC (B√åNH TH∆Ø·ªúNG) ---
                    else {
                        ctx.rotate(rotation);
                        let drawW = slotSize * 0.85;
                        let drawH = drawW * (img.height / img.width);
                        ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowBlur = 4;
                        ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                    }
                    ctx.restore();
                 }
            } else {
                // N·∫øu kh√¥ng c√≥ ƒë·ªì: Hi·ªán t√™n slot m·ªù m·ªù
                drawText(names[i], startX + slotSize/2, sy + slotSize/2, 10, "rgba(255, 255, 255, 0.3)", "center", false);
            }

            // Highlight vi·ªÅn v√†ng khi ch·ªçn
            if (this.selectedEquipSlot === i) {
                drawRect(startX-2, sy-2, slotSize+4, slotSize+4, "yellow", false, 2, 3);
            }
        }
        
        // N√∫t G·ª° B·ªè
        if (this.selectedEquipSlot !== null) {
            let btn = this.unequipBtnRect;
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 10;
            drawRect(btn.x, btn.y, btn.w, btn.h, "#d24628", true, 8); 
            drawRect(btn.x, btn.y, btn.w, btn.h, "#8c2814", false, 8, 2);
            ctx.shadowBlur = 0;
            drawText("G·ª† B·ªé", btn.x + btn.w/2, btn.y + btn.h/2, 16, "#fff", "center", true);
        }
        
        // Preview Nh√¢n v·∫≠t (B√™n ph·∫£i)
        let prevCX = this.x + this.w - 110; 
        let prevCY = this.y + 220;
        playerRef.drawUIPreview(prevCX, prevCY, 1.6);
    }

    // --- VIEW 2: TH√îNG TIN CHI TI·∫æT ---
    drawInfoTab(playerRef) {
        let startX = this.x + 20;
        let startY = this.y + 70;
        let rowH = 35;
        let labelColor = "#8daab4";
        let valueColor = "#fff";
        let wFull = this.w - 40;

        // H√†m v·∫Ω thanh bar nh·ªè (HP/MP/EXP/Stamina)
        const drawStatBar = (x, y, w, h, cur, max, colorFill) => {
            // Bg
            drawRect(x, y, w, h, "#0f1e23", true, 4);
            // Fill
            let pct = Math.max(0, Math.min(1, cur/max));
            if (pct > 0) drawRect(x, y, w * pct, h, colorFill, true, 4);
            // Border
            drawRect(x, y, w, h, "#3c5a5a", false, 4);
            // Text
            drawText(`${Math.floor(cur)}/${Math.floor(max)}`, x + w/2, y + h/2 + 1, 11, "#fff", "center", true);
        };

        // 1. T√äN & LEVEL
        drawText("H·ªç t√™n:", startX, startY + 10, 14, labelColor);
        drawText(playerRef.name, startX + 70, startY + 10, 16, COLORS.THEME_GOLD_ACTIVE, "left", true);

        drawText("C·∫•p ƒë·ªô:", startX + 180, startY + 10, 14, labelColor);
        drawText(playerRef.level, startX + 240, startY + 10, 16, "#fff", "left", true);

        drawLine(startX, startY + 30, startX + wFull, startY + 30, "rgba(255,255,255,0.1)");

        // 2. C√ÅC CH·ªà S·ªê (HP -> MP -> TH·ªÇ L·ª∞C -> EXP)
        let currentY = startY + 50;

        // --- HP ---
        drawText("Sinh L·ª±c (HP)", startX, currentY, 13, labelColor);
        drawStatBar(startX + 100, currentY - 8, wFull - 100, 16, playerRef.hp, playerRef.maxHp, "#c83232");
        
        currentY += rowH;
        // --- MP ---
        drawText("N·ªôi L·ª±c (MP)", startX, currentY, 13, labelColor);
        drawStatBar(startX + 100, currentY - 8, wFull - 100, 16, playerRef.mp, playerRef.maxMp, "#3232c8");

        currentY += rowH;
        // --- TH·ªÇ L·ª∞C ---
        drawText("Th·ªÉ L·ª±c", startX, currentY, 13, labelColor);
        // V·∫Ω thanh m√†u xanh l√° c√¢y (#46c846)
        drawStatBar(startX + 100, currentY - 8, wFull - 100, 16, playerRef.stamina, playerRef.maxStamina, "#46c846");

        currentY += rowH;
        // --- EXP ---
        drawText("Kinh Nghi·ªám", startX, currentY, 13, labelColor);
        drawStatBar(startX + 100, currentY - 8, wFull - 100, 16, playerRef.exp, playerRef.maxExp, "#dcb432");

        drawLine(startX, currentY + 25, startX + wFull, currentY + 25, "rgba(255,255,255,0.1)");
        currentY += 45;

        // 3. TH·ªêNG K√ä KH√ÅC
        let col2 = startX + wFull / 2;
        
        // S·ª©c t·∫•n c√¥ng
        drawText("T·∫•n c√¥ng:", startX, currentY, 13, labelColor);
        let dmg = 10; // M·∫∑c ƒë·ªãnh tay kh√¥ng (Base damage)
        
        // C·ªông damage d·ª±a tr√™n v≈© kh√≠
        if (playerRef.equippedWeapon === "PENCIL") dmg += 50;
        if (playerRef.equippedWeapon === "RULER") dmg += 75; // Th∆∞·ªõc K·∫ª m·∫°nh h∆°n B√∫t Ch√¨
        
        drawText(dmg, startX + 70, currentY, 14, "#fff");

        // T·ªëc ƒë·ªô
        drawText("T·ªëc ƒë·ªô:", col2, currentY, 13, labelColor);
        drawText(playerRef.speed, col2 + 60, currentY, 14, "#fff");

        currentY += 30;
        
        drawText("V≈© kh√≠:", startX, currentY, 13, labelColor);
        
        // X√°c ƒë·ªãnh t√™n v≈© kh√≠
        let wpName = "Kh√¥ng";
        if (playerRef.equippedWeapon === "PENCIL") wpName = "B√∫t Ch√¨";
        if (playerRef.equippedWeapon === "RULER") wpName = "Th∆∞·ªõc K·∫ª";
        
        // V·∫Ω t√™n (N·∫øu l√† "Kh√¥ng" th√¨ m√†u x√°m, c√≤n l·∫°i l√† m√†u v√†ng kim)
        drawText(wpName, startX + 70, currentY, 14, wpName === "Kh√¥ng" ? "#888" : COLORS.THEME_GOLD_ACTIVE);
    }
}
// --- CLASS: SKILL PANEL ---
class SkillPanel {
    constructor() {
        this.visible = false;
        this.w = 360; this.h = 450;
        this.x = 0; this.y = 0;
        this.rect = {x:0, y:0, w:0, h:0};
        this.closeBtn = {x:0, y:0, w:22, h:22};
    }

    toggle() {
        this.visible = !this.visible;
        if (this.visible) this.updatePos();
    }

    updatePos() {
         this.w = Math.min(400, SCREEN_WIDTH - 40);
         this.x = (SCREEN_WIDTH - this.w) / 2;
         this.y = (SCREEN_HEIGHT - this.h) / 2;
         this.rect = {x: this.x, y: this.y, w: this.w, h: this.h};
         this.closeBtn = {x: this.x + this.w - 30, y: this.y + 8, w: 22, h: 22};
    }

    checkClick(mx, my) {
        if (!this.visible) return false;
        
        // 1. N√∫t ƒê√≥ng (X)
        if (mx >= this.closeBtn.x && mx <= this.closeBtn.x + this.closeBtn.w &&
            my >= this.closeBtn.y && my <= this.closeBtn.y + this.closeBtn.h) {
            this.visible = false;
            return true;
        }
        
        // 2. Ch·∫∑n click xuy√™n qua b·∫£ng (ƒë·ªÉ kh√¥ng b·∫•m nh·∫ßm xu·ªëng map)
        if (mx >= this.rect.x && mx <= this.rect.x + this.rect.w &&
            my >= this.rect.y && my <= this.rect.y + this.rect.h) return true;

        return false;
    }

    draw() {
        if (!this.visible) return;
        this.updatePos();

        // --- V·∫º N·ªÄN B·∫¢NG ---
        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        drawRect(this.x, this.y, this.w, this.h, COLORS.THEME_JADE_BG, true, 8);
        drawRect(this.x, this.y, this.w, this.h, "#0a1e23", false, 8, 4);

        // --- HEADER ---
        let headerH = 40;
        drawRect(this.x, this.y, this.w, headerH, "#234b50", true, 8);
        drawLine(this.x, this.y + headerH, this.x + this.w, this.y + headerH, "#0a1e1e");
        drawText("K·ª∏ NƒÇNG V≈® KH√ç", this.x + this.w/2, this.y + 20, 18, COLORS.THEME_TEXT_WHITE, "center");

        // N√∫t Close (X)
        drawRect(this.closeBtn.x, this.closeBtn.y, this.closeBtn.w, this.closeBtn.h, "#962828", true, 4);
        drawText("X", this.closeBtn.x + 11, this.closeBtn.y + 11, 14, "#fff", "center");

        // --- N·ªòI DUNG CHI√äU TH·ª®C ---
        let startY = this.y + 70;
        let startX = this.x + 20;
        let contentW = this.w - 40;

        // 1. K·ª∏ NƒÇNG B√öT CH√å (PENCIL)
        if (player.equippedWeapon === "PENCIL") {
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BG, true, 5);
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BORDER, false, 5);

            let iconSize = 64; let iconX = startX + 15; let iconY = startY + 18;
            drawRect(iconX, iconY, iconSize, iconSize, "#000", true, 2);
            
            if (images["1012"] && images["1012"].complete) {
                ctx.drawImage(images["1012"], iconX, iconY, iconSize, iconSize);
                drawRect(iconX, iconY, iconSize, iconSize, COLORS.THEME_GOLD_ACTIVE, false, 2, 2);
            }

            let textX = iconX + iconSize + 15;
            drawText("Xuy√™n T√¢m B√∫t", textX, iconY + 15, 18, COLORS.THEME_GOLD_ACTIVE, "left", true);
            drawText("Lo·∫°i: Ch·ªß ƒë·ªông (T·∫•n c√¥ng)", textX, iconY + 38, 12, "#8daab4", "left");
            drawText("S√°t th∆∞∆°ng v·∫≠t l√Ω t·∫ßm g·∫ßn.", textX, iconY + 54, 12, "#fff", "left");
            drawText("[ƒêang k√≠ch ho·∫°t]", startX + contentW - 10, startY + 85, 11, "#46c846", "right", true);
        }
        
        // 2. K·ª∏ NƒÇNG TH∆Ø·ªöC K·∫∫ (RULER)
        else if (player.equippedWeapon === "RULER") {
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BG, true, 5);
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BORDER, false, 5);

            let iconSize = 64; let iconX = startX + 15; let iconY = startY + 18;
            drawRect(iconX, iconY, iconSize, iconSize, "#000", true, 2);
            
            if (images["1024"] && images["1024"].complete) {
                ctx.save();
                ctx.translate(iconX + iconSize/2, iconY + iconSize/2);
                ctx.rotate(Math.PI / 4); 
                let drawSize = 45;
                let ratio = images["1024"].height / images["1024"].width;
                ctx.drawImage(images["1024"], -drawSize/2, -(drawSize*ratio)/2, drawSize, drawSize*ratio);
                ctx.restore();
            }
            drawRect(iconX, iconY, iconSize, iconSize, "#ff4444", false, 2, 2);

            let textX = iconX + iconSize + 15;
            drawText("Tr·∫£m Phong Th∆∞·ªõc", textX, iconY + 15, 18, "#ff4444", "left", true);
            drawText("Lo·∫°i: C·∫≠n chi·∫øn (Slash)", textX, iconY + 38, 12, "#8daab4", "left");
            drawText("Vung th∆∞·ªõc ch√©m m·∫°nh h√¨nh v√≤ng cung.", textX, iconY + 54, 12, "#fff", "left");
            drawText("[ƒêang k√≠ch ho·∫°t]", startX + contentW - 10, startY + 85, 11, "#46c846", "right", true);
        }

        // ============================================================
        // >>> 3. K·ª∏ NƒÇNG S√öNG B√öT X√ìA (CORRECTION_PEN) - M·ªöI <<<
        // ============================================================
        else if (player.equippedWeapon === "CORRECTION_PEN") {
            // V·∫Ω khung n·ªÅn
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BG, true, 5);
            drawRect(startX, startY, contentW, 100, COLORS.THEME_SLOT_BORDER, false, 5);

            // V·∫Ω √¥ ch·ª©a Icon
            let iconSize = 64; let iconX = startX + 15; let iconY = startY + 18;
            drawRect(iconX, iconY, iconSize, iconSize, "#000", true, 2);
            
            // V·∫Ω Icon (C·∫Øt l·∫•y ph·∫ßn ƒë·∫ßu b√∫t x√≥a t·ª´ ·∫£nh 1025)
            if (images["1025"] && images["1025"].complete) {
                let img = images["1025"];
                let halfH = img.height / 2; // L·∫•y n·ª≠a tr√™n
                let drawW = 50;
                let drawH = drawW * (halfH / img.width);
                
                // CƒÉn gi·ªØa icon v√†o √¥ vu√¥ng 64x64
                let dx = iconX + (iconSize - drawW)/2;
                let dy = iconY + (iconSize - drawH)/2;

                // V·∫Ω c·∫Øt ·∫£nh: img, sx=0, sy=0, sw, sh, dx, dy, dw, dh
                ctx.drawImage(img, 0, 0, img.width, halfH, dx, dy, drawW, drawH);
            }
            // V·∫Ω vi·ªÅn m√†u Xanh Cyan (#0096aa)
            drawRect(iconX, iconY, iconSize, iconSize, "#0096aa", false, 2, 2);

            // V·∫Ω th√¥ng tin chi√™u th·ª©c
            let textX = iconX + iconSize + 15;
            drawText("Ph√°o M·ª±c T·∫©y", textX, iconY + 15, 18, "#0096aa", "left", true);
            drawText("Lo·∫°i: T·∫ßm xa (Range)", textX, iconY + 38, 12, "#8daab4", "left");
            drawText("B·∫Øn ƒë·∫°n m·ª±c g√¢y s√°t th∆∞∆°ng t·ª´ xa.", textX, iconY + 54, 12, "#fff", "left");
            drawText("[ƒêang k√≠ch ho·∫°t]", startX + contentW - 10, startY + 85, 11, "#46c846", "right", true);
        }
        // ============================================================

        // 4. CH∆ØA TRANG B·ªä V≈® KH√ç
        else {
            drawText("Ch∆∞a trang b·ªã v≈© kh√≠!", this.x + this.w/2, this.y + 150, 16, "#ff5555", "center");
            drawText("(V√†o H√†nh Trang ƒë·ªÉ trang b·ªã)", this.x + this.w/2, this.y + 180, 13, "#888", "center");
        }
    }
}
// --- CLASS: JOYSTICK
class Joystick {
    constructor() {
        this.x = 55; this.y = SCREEN_HEIGHT - 100;   
        this.radius = 30; 
        this.knobRadius = 18; // TƒÉng nh·∫π k√≠ch th∆∞·ªõc (c≈© l√† 20) ƒë·ªÉ nh√¨n r√µ h√¨nh B√°t Qu√°i
        this.knobX = this.x; this.knobY = this.y;
        this.dragging = false; this.vector = {x: 0, y: 0};
        this.touchId = null;
    }
    updatePos() { this.y = SCREEN_HEIGHT - 100; if(!this.dragging){this.knobX=this.x; this.knobY=this.y;} }
    
    handleStart(x, y, id) {
        let dx = x - this.x; let dy = y - this.y;
        if (Math.sqrt(dx*dx + dy*dy) < this.radius * 3.0) {
            this.dragging = true; this.touchId = id; this.handleMove(x, y); return true;
        } return false;
    }
    
    handleMove(x, y) {
        if (!this.dragging) return;
        let dx = x - this.x; let dy = y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist <= this.radius) { this.knobX = x; this.knobY = y; } 
        else {
            let angle = Math.atan2(dy, dx);
            this.knobX = this.x + this.radius * Math.cos(angle);
            this.knobY = this.y + this.radius * Math.sin(angle);
        }
        this.vector.x = (this.knobX - this.x) / this.radius;
        this.vector.y = (this.knobY - this.y) / this.radius;
    }
    
    handleEnd() {
        this.dragging = false; this.knobX = this.x; this.knobY = this.y;
        this.vector = {x: 0, y: 0}; this.touchId = null;
    }
    
    draw() {
        this.updatePos();
        // V·∫Ω v√≤ng tr√≤n n·ªÅn b√™n ngo√†i
        drawCircle(this.x, this.y, this.radius, COLORS.JOYSTICK_OUT); 
        
        // V·∫Ω n√∫t Joystick b·∫±ng ·∫£nh 1006
        if (images["1006"] && images["1006"].complete) {
            let img = images["1006"];
            let size = this.knobRadius * 2; 
            
            ctx.save();
            // Th√™m b√≥ng ƒë·ªï cho n√∫t n·ªïi l√™n
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 4;
            
            // V·∫Ω ·∫£nh cƒÉn gi·ªØa t√¢m knobX, knobY
            ctx.drawImage(img, this.knobX - size/2, this.knobY - size/2, size, size);
            ctx.restore();
        } else {
            // Fallback: N·∫øu ·∫£nh ch∆∞a t·∫£i xong th√¨ v·∫Ω h√¨nh tr√≤n x√°m nh∆∞ c≈©
            drawCircle(this.knobX, this.knobY, this.knobRadius, COLORS.JOYSTICK_IN);
        }
    }
}
// --- HUD BOTTOM & TOP ---
class BottomHUD {
    constructor() {
        this.btns = {};
        this.orbCenter = {hp: {x:0, y:0}, mp: {x:0, y:0}};
        this.expRect = {x:0, y:0, w:0, h:0};
        this.staminaRect = {x:0, y:0, w:0, h:0}; 
        
        this.conf = {
            btnSize: 35, iconSize: 20, spacing: 6,         
            orbSize: 55, 
            orbOffset: 32, barHeight: 4, bottomPadding: 40   
        };
    }

    updateLayout() {
        let cx = SCREEN_WIDTH / 2;
        let c = this.conf;
        let totalBtnW = (c.btnSize * 4) + (c.spacing * 3);
        let startX = cx - totalBtnW / 2;
        let y = SCREEN_HEIGHT - c.bottomPadding;

        this.btns = {
            char: {x: startX, y: y, w: c.btnSize, h: c.btnSize},
            bag: {x: startX + c.btnSize + c.spacing, y: y, w: c.btnSize, h: c.btnSize},
            skill: {x: startX + (c.btnSize + c.spacing)*2, y: y, w: c.btnSize, h: c.btnSize},
            quest: {x: startX + (c.btnSize + c.spacing)*3, y: y, w: c.btnSize, h: c.btnSize}
        };

        let expPad = 2; 
        this.expRect = {x: startX - expPad, y: y - 12, w: totalBtnW + (expPad * 2), h: c.barHeight};
        
        this.staminaRect = {
            x: this.expRect.x, 
            y: this.expRect.y + c.barHeight + 2, 
            w: this.expRect.w, 
            h: c.barHeight
        };

        this.orbCenter.hp = {x: startX - c.orbOffset, y: y + c.btnSize/2 - 5}; 
        this.orbCenter.mp = {x: startX + totalBtnW + c.orbOffset, y: y + c.btnSize/2 - 5};
    }

    checkClick(mx, my, charP, invP, skillP) {
        let inRect = (rect) => mx >= rect.x && mx <= rect.x + rect.w && my >= rect.y && my <= rect.y + rect.h;
        
        if (inRect(this.btns.char)) { invP.visible = false; skillP.visible = false; charP.toggle(); return true; }
        if (inRect(this.btns.bag)) { charP.visible = false; skillP.visible = false; invP.toggle(); return true; }
        if (inRect(this.btns.skill)) { charP.visible = false; invP.visible = false; skillP.toggle(); return true; }
        if (inRect(this.btns.quest)) { console.log("Nhi·ªám v·ª•: Ch∆∞a c√≥ t√≠nh nƒÉng"); return true; }
        return false;
    }

    // --- C·∫¨P NH·∫¨T H√ÄM N√ÄY: Th√™m tham s·ªë frameIndex ƒë·ªÉ c·∫Øt ·∫£nh ---
    drawOrb(ctx, x, y, size, current, max, color, imgKey, offsetX, offsetY, frameIndex = 0) {
        let drawW = size; let drawH = size; let r = size / 2 - 2; 
        let innerScale = 0.72; 
        let hasImage = images[imgKey] && images[imgKey].complete;
        
        // Bi·∫øn ƒë·ªÉ c·∫Øt ·∫£nh
        let sx = 0, sy = 0, sw = 0, sh = 0;
        let img = null;

        if (hasImage) {
            img = images[imgKey];
            sw = img.width; 
            sh = img.height;

            // [LOGIC M·ªöI] X·ª≠ l√Ω sprite sheet 1009
            if (imgKey === "1009") {
                sw = img.width / 2;    // C·∫Øt ƒë√¥i chi·ªÅu ngang
                sx = frameIndex * sw;  // 0 = B√™n tr√°i (ƒê·ªè), 1 = B√™n ph·∫£i (Xanh)
            }

            // T√≠nh to√°n t·ª∑ l·ªá d·ª±a tr√™n k√≠ch th∆∞·ªõc ƒê√É C·∫ÆT (sw, sh) thay v√¨ img.width g·ªëc
            let ratio = Math.min(size/sw, size/sh);
            drawW = sw * ratio; 
            drawH = sh * ratio;
            r = (drawW / 2) * innerScale;
        }

        let fluidX = x + offsetX; let fluidY = y + offsetY;
        ctx.save();
        ctx.beginPath(); ctx.arc(fluidX, fluidY, r, 0, Math.PI * 2); 
        ctx.fillStyle = "#1a0f0f"; ctx.fill(); ctx.closePath();

        if (current > 0) {
            let pct = Math.max(0, Math.min(1, current / max));
            let fluidR = r; let fluidHeight = fluidR * 2 * pct; 
            let startY = (fluidY + fluidR) - fluidHeight; 
            ctx.beginPath(); ctx.arc(fluidX, fluidY, fluidR, 0, Math.PI * 2); ctx.clip(); 
            ctx.fillStyle = color;
            ctx.fillRect(fluidX - fluidR, startY, fluidR * 2, fluidHeight);
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.fillRect(fluidX - fluidR, startY, fluidR * 2, 4);
            ctx.restore(); 
        } else { ctx.restore(); }

        if (hasImage) {
            // D√πng drawImage 9 tham s·ªë ƒë·ªÉ v·∫Ω ƒë√∫ng ph·∫ßn ·∫£nh ƒë√£ c·∫Øt
            ctx.drawImage(img, sx, sy, sw, sh, x - drawW/2, y - drawH/2, drawW, drawH);
            
            ctx.shadowColor = "rgba(0, 0, 0, 0.5)"; ctx.shadowBlur = 2;
            let percent = Math.floor((current / max) * 100);
            drawText(`${percent}%`, x, y, 9, "rgba(255, 255, 255, 0.6)", "center", false);
            ctx.shadowBlur = 0;
        }
    }

    draw(player) {
        this.updateLayout(); 
        let c = this.conf;
        let r = 2; 

        // 1. V·∫º D√ÇY & THANH BAR (GI·ªÆ NGUY√äN)
        ctx.lineWidth = 2; 
        drawLine(this.orbCenter.hp.x, this.orbCenter.hp.y, this.expRect.x, this.expRect.y + c.barHeight/2, "#461414");
        drawLine(this.orbCenter.mp.x, this.orbCenter.mp.y, this.expRect.x + this.expRect.w, this.expRect.y + c.barHeight/2, "#141446");

        // EXP
        drawRect(this.expRect.x, this.expRect.y, this.expRect.w, this.expRect.h, "#1e1919", true, r);
        if (player.level < 99) {
            let ratio = Math.max(0, Math.min(1, player.exp / player.maxExp));
            let fillW = this.expRect.w * ratio;
            if (fillW > 0) drawRect(this.expRect.x, this.expRect.y, fillW, this.expRect.h, "#dcb432", true, r);
        } else {
            drawRect(this.expRect.x, this.expRect.y, this.expRect.w, this.expRect.h, "#dcb432", true, r);
        }
        drawRect(this.expRect.x, this.expRect.y, this.expRect.w, this.expRect.h, "#0a0a0a", false, r, 1);

        // Stamina
        drawRect(this.staminaRect.x, this.staminaRect.y, this.staminaRect.w, this.staminaRect.h, "#1e1919", true, r);
        let stamRatio = Math.max(0, Math.min(1, player.stamina / player.maxStamina));
        let stamFillW = this.staminaRect.w * stamRatio;
        if (stamFillW > 0) {
            drawRect(this.staminaRect.x, this.staminaRect.y, stamFillW, this.staminaRect.h, "#46c846", true, r);
        }
        drawRect(this.staminaRect.x, this.staminaRect.y, this.staminaRect.w, this.staminaRect.h, "#0a0a0a", false, r, 1);

        // 2. V·∫º ORB (GI·ªÆ NGUY√äN)
        this.drawOrb(ctx, this.orbCenter.hp.x, this.orbCenter.hp.y, c.orbSize, player.hp, player.maxHp, "#c83232", "1009", 1, 2, 0); 
        this.drawOrb(ctx, this.orbCenter.mp.x, this.orbCenter.mp.y, c.orbSize, player.mp, player.maxMp, "#3232c8", "1009", 1, 2, 1); 

        // 3. V·∫º N√öT MENU D√ôNG ·∫¢NH 1005 (ƒê√É S·ª¨A T·ª™ 1004 -> 1005)
        const drawSheetBtn = (rect, col, row) => {
            // S·ª¨A ·ªû ƒê√ÇY: D√πng 1005 thay v√¨ 1004
            if (images["1005"] && images["1005"].complete) {
                let img = images["1005"];
                
                let frameW = img.width / 2;
                let frameH = img.height / 2;
                
                let sx = col * frameW;
                let sy = row * frameH;
                
                let iconScale = 1.2; 
                let displaySize = c.iconSize * iconScale;
                let dx = rect.x + (rect.w - displaySize)/2;
                let dy = rect.y + (rect.h - displaySize)/2;

                ctx.drawImage(img, sx, sy, frameW, frameH, dx, dy, displaySize, displaySize);
            }
        };

        drawSheetBtn(this.btns.char, 0, 0);  
        drawSheetBtn(this.btns.bag, 1, 0);   
        drawSheetBtn(this.btns.skill, 0, 1); 
        drawSheetBtn(this.btns.quest, 1, 1); 
    }
}
// --- CLASS: MINI MAP ---
class MiniMap {
    constructor() {
        this.radius = 40; 
        this.margin = 5; // Gi·∫£m t·ª´ 15 xu·ªëng 5 ƒë·ªÉ map x√≠ch l√™n cao (ngang t·∫ßm avatar)
        this.alpha = 0.85; 
        
        // T√≠nh to√°n t·ª∑ l·ªá thu nh·ªè
        this.scaleY = (this.radius * 2) / WORLD_HEIGHT; 
        this.scaleX = this.scaleY; 
        
        this.drawW = WORLD_WIDTH * this.scaleX;
        this.drawH = WORLD_HEIGHT * this.scaleY;
    }

    draw(ctx, player, enemies, camX, camY) {
        // 1. X√°c ƒë·ªãnh t√¢m c·ªßa Mini Map (G√≥c tr√™n ph·∫£i)
        let cx = SCREEN_WIDTH - this.radius - this.margin;
        let cy = this.radius + this.margin; 
        // V·ªõi margin = 5, b√°n k√≠nh = 40 => T√¢m Y = 45 (G·∫ßn v·ªõi Avatar Y=35 h∆°n)

        ctx.save();
        
        // 2. V·∫Ω khung tr√≤n & N·ªÅn (Mask)
        ctx.beginPath();
        ctx.arc(cx, cy, this.radius, 0, Math.PI * 2);
        
        // ƒê·ªï m√†u n·ªÅn gi·∫•y
        ctx.fillStyle = "#f5f5f0"; 
        ctx.globalAlpha = this.alpha;
        ctx.fill();
        
        // Vi·ªÅn tr√≤n bao quanh
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#505a64"; 
        ctx.globalAlpha = 1.0;
        ctx.stroke();

        // 3. T·∫†O M·∫∂T N·∫† C·∫ÆT (CLIP)
        ctx.clip(); 

        // --- V·∫º N·ªòI DUNG B√äN TRONG ---
        
        let startX = cx - (this.drawW / 2);
        let startY = cy - (this.drawH / 2);

        // b. V·∫Ω Khung Camera
        let viewW = SCREEN_WIDTH * this.scaleX;
        let viewH = SCREEN_HEIGHT * this.scaleY;
        let viewX = startX + (camX * this.scaleX);
        let viewY = startY + (camY * this.scaleY);

        ctx.strokeStyle = "rgba(50, 50, 50, 0.3)";
        ctx.lineWidth = 1;
        ctx.strokeRect(viewX, viewY, viewW, viewH);

        // c. V·∫Ω Ng∆∞·ªùi ch∆°i
        let px = startX + (player.x * this.scaleX);
        let py = startY + (player.y * this.scaleY);

        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fillStyle = "#00cc00";
        ctx.fill();

        ctx.restore();
        
        // Ch·ªØ h∆∞·ªõng B·∫Øc "N"
        ctx.fillStyle = "#505a64";
        ctx.font = "bold 10px Arial";
        ctx.textAlign = "center";
        ctx.fillText("N", cx, cy - this.radius + 12);
    }
}
// --- C·∫¨P NH·∫¨T: AVATAR
function drawTopLeftHUD(player) {
    let cx = 35, cy = 35;   
    let r = 22;             
    
    // 1. V·∫Ω Khung Avatar
    drawCircle(cx, cy, r + 2, "#2d2d2d"); 
    drawCircle(cx, cy, r, "#f2f2f2");     
    
    // B·∫Øt ƒë·∫ßu v√πng v·∫Ω b√™n trong m·∫∑t (Clip mask)
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.clip();

    // 2. V·∫Ω M·∫Øt (S·∫Øc l·∫πm)
    ctx.fillStyle = "#141414";
    ctx.beginPath(); ctx.ellipse(cx - 7, cy + 3, 2.5, 4, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx + 7, cy + 3, 2.5, 4, 0, 0, Math.PI*2); ctx.fill();

    // 3. V·∫Ω L√¥ng m√†y (Nh√≠u m√†y nghi√™m t√∫c)
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = "#141414";
    ctx.lineCap = "round";
    ctx.beginPath(); ctx.moveTo(cx - 13, cy - 3); ctx.lineTo(cx - 4, cy + 1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 4, cy + 1); ctx.lineTo(cx + 13, cy - 3); ctx.stroke();

    // 4. V·∫º MI·ªÜNG (NH·∫æCH M√âP)
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.moveTo(cx - 5, cy + 11); 
    ctx.quadraticCurveTo(cx, cy + 13, cx + 5, cy + 10); 
    ctx.stroke();

    // 5. V·∫Ω BƒÉng C√° Nh√¢n
    ctx.save();
    ctx.translate(cx + 6, cy - 10); 
    ctx.rotate(-Math.PI / 6);       
    
    let bw = 14, bh = 5;
    ctx.fillStyle = "#e6b48c"; 
    ctx.strokeStyle = "#c89678"; 
    ctx.lineWidth = 1;
    
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(-bw/2, -bh/2, bw, bh, 2);
    else ctx.rect(-bw/2, -bh/2, bw, bh);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#dcb496";
    ctx.beginPath(); ctx.arc(0, 0, 1, 0, Math.PI*2); ctx.fill();
    
    ctx.restore(); 
    ctx.restore();

    // 6. T√™n & Level
    let tx = cx + r + 10; 
    ctx.shadowColor = "rgba(255, 255, 255, 0.8)"; ctx.shadowBlur = 2;
    drawText(player.name, tx, cy - 8, 14, "#141414", "left", true); 
    ctx.shadowBlur = 0;
    drawText(`Lv.${player.level}`, tx, cy + 10, 11, "#505050", "left", true);
}
// --- SETUP GAME & LOGIC MENU ---
const player = new Stickman(WORLD_WIDTH/2, WORLD_HEIGHT/2);
let activePet = null; 
const joystick = new Joystick();
const inventory = new InventoryPanel();
const charPanel = new CharacterPanel();
const skillPanel = new SkillPanel();
const hud = new BottomHUD();
const attackBtn = new AttackButton();
const dashButton = new DashButton();
const sitButton = new SitButton();
const miniMap = new MiniMap();

// --- BI·∫æN QU·∫¢N L√ù TR·∫†NG TH√ÅI GAME ---
// false: Ch∆∞a c√≥ nh√¢n v·∫≠t (n√∫t T·∫°o s√°ng). true: ƒêang ch∆°i (n√∫t Xo√°/L∆∞u s√°ng).
let isGameActive = false; 

// 1. H√ÄM C·∫¨P NH·∫¨T M√ÄU S·∫ÆC N√öT B·∫§M
function updateMenuButtons() {
    const btnCreate = document.getElementById("btnCreate");
    const btnDelete = document.getElementById("btnDelete");
    const btnSave = document.getElementById("btnSaveManual");

    if (!btnCreate || !btnDelete || !btnSave) return;

    if (isGameActive) {
        // --- TR·∫†NG TH√ÅI ƒêANG CH∆†I ---
        btnCreate.disabled = true;
        btnCreate.style.opacity = "0.3"; 
        btnCreate.style.cursor = "default";
        btnCreate.classList.remove("btn-highlight"); // T·∫Øt hi·ªáu ·ª©ng nh·∫•p nh√°y

        btnDelete.disabled = false;
        btnDelete.style.opacity = "1";
        btnDelete.style.cursor = "pointer";

        btnSave.disabled = false;
        btnSave.style.opacity = "1";
        btnSave.style.cursor = "pointer";
    } else {
        // --- TR·∫†NG TH√ÅI CH∆ØA C√ì NH√ÇN V·∫¨T ---
        btnCreate.disabled = false;
        btnCreate.style.opacity = "1";
        btnCreate.style.cursor = "pointer";
        btnCreate.classList.add("btn-highlight"); // B·∫¨T HI·ªÜU ·ª®NG NH·∫§P NH√ÅY

        btnDelete.disabled = true;
        btnDelete.style.opacity = "0.3";
        btnDelete.style.cursor = "default";

        btnSave.disabled = true;
        btnSave.style.opacity = "0.3";
        btnSave.style.cursor = "default";
    }
}
// H√ÄM HI·ªÜN TH√îNG B√ÅO ƒê·∫∏P
function showToast(message) {
    var x = document.getElementById("toast-notification");
    if (!x) return;
    
    x.innerText = message;
    x.className = "show"; // Th√™m class ƒë·ªÉ hi·ªán v√† bay l√™n
    
    // ·∫®n sau 3 gi√¢y
    setTimeout(function(){ 
        x.className = x.className.replace("show", ""); 
    }, 3000);
}

// 2. H√ÄM HI·ªÜN/·∫®N MENU
function toggleAvatarMenu() {
    const menu = document.getElementById("avatarMenu");
    if (!menu) return;

    if (menu.style.display === "none" || menu.style.display === "") {
        updateMenuButtons(); // C·∫≠p nh·∫≠t m√†u n√∫t tr∆∞·ªõc khi hi·ªán
        menu.style.display = "block";
    } else {
        menu.style.display = "none";
    }
}

// --- 3. H√ÄM X·ª¨ L√ù N√öT "T·∫†O" (ƒê√É S·ª¨A: HI·ªÜN B·∫¢NG NH·∫¨P T√äN) ---
function actionCreate() {
    if (isGameActive) return; // ƒêang ch∆°i th√¨ kh√¥ng ƒë∆∞·ª£c t·∫°o ƒë√®
    
    // ·∫®n menu ch√≠nh ƒëi
    toggleAvatarMenu();
    
    // Hi·ªán b·∫£ng nh·∫≠p t√™n
    const modal = document.getElementById("nameModal");
    const input = document.getElementById("playerNameInput");
    
    if (modal && input) {
        modal.style.display = "block";
        input.value = ""; // X√≥a t√™n c≈© n·∫øu c√≥
        input.focus();    // ƒê·∫∑t con tr·ªè chu·ªôt v√†o √¥ nh·∫≠p
    }
}

// --- H√ÄM H·ª¶Y T·∫†O NH√ÇN V·∫¨T ---
function closeNameModal() {
    document.getElementById("nameModal").style.display = "none";
    // M·ªü l·∫°i menu ch√≠nh ƒë·ªÉ ng∆∞·ªùi ch∆°i ch·ªçn l·∫°i n·∫øu mu·ªën
    toggleAvatarMenu();
}

// --- H√ÄM X√ÅC NH·∫¨N T·∫†O NH√ÇN V·∫¨T ---
function confirmCreate() {
    const input = document.getElementById("playerNameInput");
    const rawName = input.value.trim();
    
    // Ki·ªÉm tra t√™n h·ª£p l·ªá
    if (!rawName) {
        alert("Vui l√≤ng nh·∫≠p t√™n cho nh√¢n v·∫≠t!");
        input.focus();
        return;
    }
    
    if (rawName.length > 10) {
        alert("T√™n qu√° d√†i! T·ªëi ƒëa 10 k√Ω t·ª±.");
        return;
    }

    // ƒê√≥ng b·∫£ng nh·∫≠p t√™n
    document.getElementById("nameModal").style.display = "none";

    // --- B·∫ÆT ƒê·∫¶U LOGIC T·∫†O GAME C≈® ---
    
    // 1. C·∫≠p nh·∫≠t t√™n t·ª´ √¥ nh·∫≠p
    player.name = rawName;
    
    // 2. Reset to√†n b·ªô ch·ªâ s·ªë v·ªÅ m·∫∑c ƒë·ªãnh
    player.level = 1;
    player.exp = 0; player.maxExp = 200;
    player.hp = 1000; player.maxHp = 1000;
    player.mp = 1000; player.maxMp = 1000;
    player.stamina = 100; player.maxStamina = 100;
    player.x = WORLD_WIDTH / 2;
    player.y = WORLD_HEIGHT / 2;
    player.equippedWeapon = null;
    player.hasSlime = false;
    activePet = null; // Thu h·ªìi Pet n·∫øu c√≥

    // 3. Reset t√∫i ƒë·ªì v√† cho ƒë·ªì t√¢n th·ªß
    inventory.gold = 99999;
    // T·∫°o m·∫£ng r·ªóng m·ªõi cho t√∫i ƒë·ªì
    inventory.items = Array(inventory.rows).fill().map(() => Array(inventory.cols).fill(null));
    
    // Th√™m v·∫≠t ph·∫©m kh·ªüi ƒë·∫ßu
    inventory.addItem("PENCIL", 1, "1007");
    inventory.addItem("HP_POTION", 5, "1013");
    inventory.addItem("MP_POTION", 5, "1013");

    // 4. K√≠ch ho·∫°t game
    isGameActive = true;
    saveGame(player, inventory, true); // L∆∞u ngay l·∫≠p t·ª©c
    
    // G·ªçi th√¥ng b√°o Toast ƒë·∫πp m·∫Øt thay v√¨ alert x·∫•u x√≠
    showToast(`Xin ch√†o ${player.name}! B·∫Øt ƒë·∫ßu h√†nh tr√¨nh.`);
}

// 4. H√ÄM X·ª¨ L√ù N√öT "XO√Å"
function actionDelete() {
    if (!isGameActive) return;

    if (confirm("C·∫¢NH B√ÅO: Nh√¢n v·∫≠t s·∫Ω b·ªã xo√° vƒ©nh vi·ªÖn!\nB·∫°n c√≥ ch·∫Øc ch·∫Øn kh√¥ng?")) {
        // Xo√° d·ªØ li·ªáu trong b·ªô nh·ªõ tr√¨nh duy·ªát
        localStorage.removeItem("rpg_pencil_slots");
        
        // ƒê∆∞a game v·ªÅ tr·∫°ng th√°i ch·ªù
        isGameActive = false;
        player.x = -9999; // Gi·∫•u nh√¢n v·∫≠t ƒëi ch·ªó kh√°c
        activePet = null; // Xo√° pet
        
        toggleAvatarMenu(); // ƒê√≥ng menu
        alert("ƒê√£ xo√° d·ªØ li·ªáu. H√£y b·∫•m 'T·∫°o' ƒë·ªÉ ch∆°i l·∫°i.");
    }
}

// 5. H√ÄM X·ª¨ L√ù N√öT "L∆ØU" (ƒê√É C·∫¨P NH·∫¨T)
function actionSaveManual() {
    if (!isGameActive) return;
    
    // G·ªçi h√†m saveGame v·ªõi tham s·ªë true (silent) ƒë·ªÉ kh√¥ng hi·ªán alert c≈©
    saveGame(player, inventory, true);
    
    // G·ªçi th√¥ng b√°o Toast ƒë·∫πp m·∫Øt
    showToast("‚úÖ ƒê√£ l∆∞u d·ªØ li·ªáu an to√†n!");
    
    toggleAvatarMenu(); // ƒê√≥ng menu
}
// --- H√ÄM X·ª¨ L√ù CLICK / CH·∫†M M√ÄN H√åNH ---
function handleStart(x, y, id="mouse") {
    
    // 1. [M·ªöI] KI·ªÇM TRA CLICK V√ÄO AVATAR (G√ìC TR√ÅI TR√äN)
    // T·ªça ƒë·ªô t√¢m Avatar l√† (35, 35). Ta cho b√°n k√≠nh v√πng b·∫•m l√† 40px ƒë·ªÉ d·ªÖ b·∫•m tr√∫ng.
    let distAvatar = Math.sqrt((x - 35)**2 + (y - 35)**2);
    
    if (distAvatar <= 40) { 
        // N·∫øu kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm b·∫•m ƒë·∫øn t√¢m Avatar nh·ªè h∆°n 40px
        toggleAvatarMenu(); // G·ªçi h√†m m·ªü/ƒë√≥ng menu (ƒë√£ vi·∫øt ·ªü B∆∞·ªõc 2)
        return; // D·ª´ng ngay l·∫≠p t·ª©c, kh√¥ng cho nh√¢n v·∫≠t di chuy·ªÉn hay ch√©m gi√≥
    }
    
    // 2. X·ª¨ L√ù ƒê√ìNG MENU KHI B·∫§M RA NGO√ÄI
    const menu = document.getElementById("avatarMenu");
    // N·∫øu menu ƒëang hi·ªán (display l√† block)
    if (menu && menu.style.display === "block") {
        // L·∫•y khung h√¨nh ch·ªØ nh·∫≠t c·ªßa menu
        let rect = menu.getBoundingClientRect();
        
        // Ki·ªÉm tra xem ƒëi·ªÉm b·∫•m (x,y) c√≥ n·∫±m NGO√ÄI khung menu kh√¥ng
        // N·∫øu x nh·ªè h∆°n b√™n tr√°i HO·∫∂C x l·ªõn h∆°n b√™n ph·∫£i...
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
            menu.style.display = "none"; // ƒê√≥ng menu l·∫°i cho g·ªçn
        }
        
        // L∆∞u √Ω: Kh√¥ng 'return' ·ªü ƒë√¢y, ƒë·ªÉ ng∆∞·ªùi ch∆°i c√≥ th·ªÉ v·ª´a ƒë√≥ng menu v·ª´a di chuy·ªÉn lu√¥n
    }
    
    // 3. C√ÅC LOGIC C≈® C·ª¶A GAME
    // Ki·ªÉm tra click v√†o c√°c b·∫£ng UI (H√†nh trang, K·ªπ nƒÉng...)
    if (charPanel.checkClick(x, y)) return;
    if (inventory.checkClick(x, y)) return; 
    if (skillPanel.checkClick(x, y)) return;
    
    // N·∫øu ƒëang m·ªü b·∫£ng n√†o ƒë√≥ th√¨ ch·∫∑n thao t√°c di chuy·ªÉn/ƒë√°nh
    if (charPanel.visible || inventory.visible || skillPanel.visible) return;

    // Ki·ªÉm tra n√∫t t·∫•n c√¥ng
    if (attackBtn.checkClick(x, y)) return;

    // Ki·ªÉm tra n√∫t l∆∞·ªõt (Dash)
    if (dashButton.checkClick(x, y, player, joystick.vector.x, joystick.vector.y)) return;
    
    // Ki·ªÉm tra n√∫t Ng·ªìi
    if (sitButton.checkClick(x, y)) return;

    // Ki·ªÉm tra c√°c n√∫t ch·ª©c nƒÉng d∆∞·ªõi ƒë√°y (HUD)
    if (hud.checkClick(x, y, charPanel, inventory, skillPanel)) return;

    // Cu·ªëi c√πng: N·∫øu kh√¥ng b·∫•m tr√∫ng n√∫t n√†o -> Di chuy·ªÉn Joystick
    // (Ch·ªâ cho di chuy·ªÉn n·∫øu Game ƒëang Active - ƒê√£ vi·∫øt ·ªü B∆∞·ªõc 2)
    if (typeof isGameActive !== 'undefined' && !isGameActive) {
        return; // N·∫øu ch∆∞a t·∫°o nh√¢n v·∫≠t th√¨ kh√¥ng cho di chuy·ªÉn
    }
    
    joystick.handleStart(x, y, id);
}

function handleMove(x, y, id="mouse") {
    if (id === joystick.touchId || id === "mouse") joystick.handleMove(x, y);
}

function handleEnd(id="mouse") {
    if (id === joystick.touchId || id === "mouse") joystick.handleEnd();
}
// --- H·ªÜ TH·ªêNG NPC & C·ª¨A H√ÄNG ---
// --- H√ÄM V·∫º NPC D∆Ø·ª¢C Sƒ® ---
function drawPharmacist(camX, camY) {
    let s = 0.6; // T·ªâ l·ªá scale
    let color = "#006400"; 
    
    // T·ªça ƒë·ªô ng∆∞·ªùi
    let cx = NPC_PHARMACIST.x - camX;
    let cy = NPC_PHARMACIST.y - camY;

    // --- 1. V·∫º K√çNH HI·ªÇN VI (ƒê√É S·ª¨A L·ªñI V·ªä TR√ç) ---
    if (images["1019"] && images["1019"].complete) {
        let bgW = 100 * s; 
        let bgH = bgW * (images["1019"].height / images["1019"].width);
        
        // [QUAN TR·ªåNG] ƒê·∫∑t k√≠nh n·∫±m ngay c·∫°nh ch√¢n D∆∞·ª£c sƒ©
        // D·ªùi sang tr√°i m·ªôt ch√∫t (-60*s) ƒë·ªÉ kh√¥ng che m·∫∑t ng∆∞·ªùi
        ctx.drawImage(images["1019"], cx - 60*s, cy - 150*s, bgW, bgH);
    }

    // --- 2. V·∫º B√ìNG ƒê·ªî ---
    ctx.save();
    ctx.translate(cx, cy + 34 * s); 
    ctx.scale(1, 0.4); 
    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)"; ctx.fill();
    ctx.restore();

    // --- 3. V·∫º NG∆Ø·ªúI (STICKMAN) ---
    let time = Date.now() / 250; 
    let breathY = Math.sin(time) * 1.5 * s; 

    let hipX = cx; let hipY = cy; 
    let footLX = cx + 12 * s; let footRX = cx - 12 * s;
    let footLY = cy + 34 * s; let footRY = cy + 34 * s;
    let shoulderX = cx; let shoulderY = (cy - 35 * s) + breathY; 
    let headX = cx; let headY = (cy - 50 * s) + breathY; 
    let handLX = shoulderX + 13 * s; let handRX = shoulderX - 13 * s;
    let handLY = shoulderY + 28 * s; let handRY = shoulderY + 28 * s;

    // Render b·ªô ph·∫≠n
    drawLimb([hipX, hipY], [footLX, footLY], 35 * s, color, 1);
    drawLimb([hipX, hipY], [footRX, footRY], 35 * s, color, -1);
    drawLine(hipX, hipY, shoulderX, shoulderY, color, 3);
    drawCircle(headX, headY, 13 * s, color, true); 
    drawText("+", headX, headY + 2, 14 * s, "#fff", "center", true);
    drawLimb([shoulderX, shoulderY], [handLX, handLY], 30 * s, color, 1);
    drawLimb([shoulderX, shoulderY], [handRX, handRY], 30 * s, color, -1);

    // B√¨nh thu·ªëc tr√™n tay
    if (images["1013"] && images["1013"].complete) {
        let pSize = 24 * s; 
        ctx.save();
        ctx.translate(handRX, handRY);
        ctx.rotate(Math.sin(time) * 0.1); 
        let srcImg = images["1013"];
        ctx.drawImage(srcImg, 0, 0, srcImg.width/2, srcImg.height/2, -pSize/2, -pSize/2, pSize, pSize);
        ctx.restore();
    }
}
// --- H√ÄM V·∫º NPC TH·ª¢ R√àN ---
function drawBlacksmith(camX, camY) {
    let s = 0.6; 
    let color = "#5a5a5a"; 
    
    let cx = NPC_BLACKSMITH.x - camX;
    let cy = NPC_BLACKSMITH.y - camY;

    // --- 1. V·∫º C√ÅI D·∫¨P GHIM (L√ÄM B√ÄN R√àN) ---
    if (images["1017"] && images["1017"].complete) {
        let anvilW = 160 * s; 
        let anvilH = anvilW * (images["1017"].height / images["1017"].width);
        
        // H·∫° th·∫•p xu·ªëng (cy + 10*s) ƒë·ªÉ n√≥ n·∫±m tr√™n m·∫∑t ƒë·∫•t
        // D·ªùi sang tr√°i (cx - 80*s) ƒë·ªÉ Th·ª£ r√®n ƒë·ª©ng b√™n c·∫°nh g√µ b√∫a v√†o
        ctx.drawImage(images["1017"], cx - 80*s, cy - 40*s, anvilW, anvilH);
    }

    // --- 2. V·∫º B√ìNG ƒê·ªî ---
    ctx.save();
    ctx.translate(cx, cy + 34 * s); 
    ctx.scale(1, 0.4); 
    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)"; ctx.fill();
    ctx.restore();

    // --- 3. V·∫º TH·ª¢ R√àN ---
    let time = Date.now() / 250; 
    let breathY = Math.sin(time) * 1.5 * s; 

    let hipX = cx; let hipY = cy; 
    let footLX = cx + 12 * s; let footRX = cx - 12 * s;
    let footLY = cy + 34 * s; let footRY = cy + 34 * s;
    let shoulderX = cx; let shoulderY = (cy - 35 * s) + breathY; 
    let headX = cx; let headY = (cy - 50 * s) + breathY; 
    let handLX = shoulderX + 13 * s; let handRX = shoulderX - 13 * s;
    let handLY = shoulderY + 28 * s; let handRY = shoulderY + 28 * s;

    // C√¢y b√∫a sau l∆∞ng
    if (images["1018"] && images["1018"].complete) {
        let hW = 60 * s; 
        let hH = hW * (images["1018"].height / images["1018"].width);
        ctx.save();
        ctx.translate(shoulderX, shoulderY + 10*s); 
        ctx.rotate(-Math.PI / 4); 
        ctx.drawImage(images["1018"], -hW/2, -hH/2, hW, hH);
        ctx.restore();
    }

    drawLimb([hipX, hipY], [footLX, footLY], 35 * s, color, 1);
    drawLimb([hipX, hipY], [footRX, footRY], 35 * s, color, -1);
    drawLine(hipX, hipY, shoulderX, shoulderY, color, 3);
    drawCircle(headX, headY, 13 * s, color, true); 
    drawRect(headX - 14*s, headY - 8*s, 28*s, 5*s, "#333", true); 
    drawLimb([shoulderX, shoulderY], [handLX, handLY], 30 * s, color, 1);
    drawLimb([shoulderX, shoulderY], [handRX, handRY], 30 * s, color, -1);
}
// --- H√ÄM V·∫º NPC DORAEMON (ƒê√É S·ª¨A: CH√ÇN C·ªê ƒê·ªäNH, TH·ªû NH·∫∏) ---
function drawDoraemon(camX, camY) {
    let s = 1; 
    let cx = NPC_DORAEMON.x - camX;
    let cy = NPC_DORAEMON.y - camY;

    // 1. V·∫º C√ÅNH C·ª¨A TH·∫¶N K·ª≤ (N·∫∞M SAU L∆ØNG)
    if (images["1020"] && images["1020"].complete) {
        let doorW = 80 * s; 
        let doorH = doorW * (images["1020"].height / images["1020"].width);
        ctx.drawImage(images["1020"], cx - doorW/2, cy - 100*s, doorW, doorH); 
    }

    // 2. V·∫º DORAEMON
    if (images["1008"] && images["1008"].complete) {
        let img = images["1008"];
        let frameW = img.width / 2;
        let frameH = img.height;
        let isBlinking = (Date.now() % 4000) < 200; // Nh√°y m·∫Øt m·ªói 4 gi√¢y
        
        let sx = isBlinking ? frameW : 0;      
        let fixX = isBlinking ? 6.5 * s : 0;    

        // --- HI·ªÜU ·ª®NG TH·ªû C·ªê ƒê·ªäNH CH√ÇN ---
        // 1. ƒê·ªìng b·ªô t·ªëc ƒë·ªô v·ªõi NPC kh√°c (chia cho 250 thay v√¨ 450)
        let time = Date.now() / 600; 
        
        // 2. Ch·ªâ thay ƒë·ªïi chi·ªÅu cao (Y) nh·∫π, gi·ªØ nguy√™n chi·ªÅu ngang (X)
        let scaleX = 1; 
        let scaleY = 1 + Math.sin(time) * 0.02; // Co gi√£n nh·∫π bi√™n ƒë·ªô 2%

        let baseW = 50 * s; 
        let baseH = baseW * (frameH / frameW); 
        
        let currentW = baseW * scaleX;
        let currentH = baseH * scaleY; // Chi·ªÅu cao thay ƒë·ªïi theo nh·ªãp th·ªü

        // 3. T√≠nh to√°n v·ªã tr√≠ v·∫Ω: 
        // L·∫•y m·∫∑t ƒë·∫•t l√†m chu·∫©n (cy + 60*s), v·∫Ω ng∆∞·ª£c l√™n tr√™n (- currentH)
        // Vi·ªác n√†y ƒë·∫£m b·∫£o ch√¢n lu√¥n d√≠nh ch·∫∑t xu·ªëng ƒë·∫•t khi ng∆∞·ªùi ph·ªìng l√™n
        let drawX = (cx - currentW / 2) + fixX; 
        let drawY = (cy + 60*s) - currentH; 

        // B√≥ng ƒë·ªï (Gi·ªØ nguy√™n k√≠ch th∆∞·ªõc, kh√¥ng co gi√£n theo ng∆∞·ªùi)
        ctx.save();
        ctx.translate(cx + 2*s, cy + 35*s); 
        ctx.scale(1, 0.25); 
        ctx.beginPath();
        ctx.arc(0, 0, 20 * s, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fill();
        ctx.restore();

        // V·∫Ω ·∫£nh Doraemon
        ctx.drawImage(img, sx, 0, frameW, frameH, drawX, drawY, currentW, currentH);
    }
}

// --- H√†m M·ªü C·ª≠a H√†ng ---
const createItemHTML = (img, name, price, code) => {
    let iconHTML = "";
    let imgSrc = img.includes(".") ? img : img + ".png";

    // 1. N·∫æU L√Ä C√ÅC B√åNH THU·ªêC (Gi·ªØ nguy√™n logic c≈©)
    if (code === "HP_POTION" || code === "MP_POTION" || code === "DUAL_POTION" || code === "STAMINA_POTION") {
        let bgPos = "0% 0%";
        if (code === "MP_POTION") bgPos = "100% 0%";
        else if (code === "DUAL_POTION") bgPos = "0% 100%";
        else if (code === "STAMINA_POTION") bgPos = "100% 100%";

        iconHTML = `<div style="
            width: 32px; height: 32px; margin-right: 10px;
            background-image: url('${imgSrc}');
            background-size: 200% 200%; 
            background-position: ${bgPos};
            border-radius: 4px;
        "></div>`;
    }
    
    // >>> 2. TH√äM M·ªöI: X·ª¨ L√ù RI√äNG CHO PET
    else if (code === "PET_SLIME") {
        iconHTML = `<div style="
            width: 40px; height: 40px; margin-right: 10px;
            background-image: url('${imgSrc}');
            
            /* GI·∫¢I TH√çCH: ·∫¢nh c√≥ 3 c·ªôt, 4 h√†ng. Ta ph√≥ng to 300% ngang v√† 400% d·ªçc 
               ƒë·ªÉ √¥ div 40px ch·ªâ ch·ª©a v·ª´a ƒë√∫ng 1 h√¨nh nh·ªè */
            background-size: 300% 400%;   
            
            /* V·ªä TR√ç: 50% l√† l·∫•y c·ªôt gi·ªØa, 0% l√† l·∫•y h√†ng ƒë·∫ßu ti√™n (T∆∞ th·∫ø ƒë·ª©ng) */
            background-position: 50% 0%;  
            
            image-rendering: pixelated; /* Gi·ªØ ·∫£nh s·∫Øc n√©t, kh√¥ng b·ªã m·ªù */
            background-repeat: no-repeat;
        "></div>`;
    }

    // 3. C√ÅC V·∫¨T PH·∫®M KH√ÅC (V≈© kh√≠,...)
    else {
        let imgStyle = "width: 32px; height: 32px; margin-right: 10px;";

        if (code === "PENCIL") {
            imgStyle = "width: 45px; height: auto; transform: rotate(-45deg); margin-right: 5px; margin-left: -5px;";
        } 
        else if (code === "RULER") {
            imgStyle = "width: 45px; height: auto; transform: rotate(0deg); margin-right: 5px; margin-left: -5px;";
        }
        else if (code === "CORRECTION_PEN") {
            imgStyle = "width: 45px; height: 25px; object-fit: cover; object-position: bottom; transform: rotate(-45deg); margin-right: 5px; margin-left: -5px;";
        }

        iconHTML = `<div style="width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; margin-right: 10px;">
                        <img src="${imgSrc}" style="${imgStyle}">
                    </div>`;
    }

    return `
    <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.1); margin-bottom: 10px; padding: 8px; border-radius: 5px; overflow: hidden;">
        ${iconHTML}
        <div style="flex-grow: 1;">
            <div style="font-weight: bold; font-size: 14px;">${name}</div>
            <div style="color: #ffd700; font-size: 12px;">${price} ü•ú</div>
        </div>
        <button onclick="buyItem('${code}', ${price}, '${name}', '${img}')" style="background: #28a745; border: none; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Mua</button>
    </div>`;
};

// 2. H√ÄM X·ª¨ L√ù CHUY·ªÇN TAB (ƒê·ªÇ RA NGO√ÄI LU√îN)
function switchBlacksmithTab(tabName) {
    const listDiv = document.getElementById("blacksmithList");
    const btnSpear = document.getElementById("btnTabSpear");
    const btnBlade = document.getElementById("btnTabBlade");
    // L·∫•y th√™m n√∫t S√∫ng
    const btnGun = document.getElementById("btnTabGun");

    // N·∫øu ch∆∞a m·ªü shop m√† g·ªçi h√†m th√¨ return
    if (!listDiv) return;

    // ƒê·ªãnh nghƒ©a Style (Active / Inactive)
    const styleActive = "flex: 1; padding: 10px; background: #d24628; color: #fff; border: 1px solid #ff4444; border-radius: 5px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(210, 70, 40, 0.5); transition: all 0.2s;";
    const styleInactive = "flex: 1; padding: 10px; background: #2a2a2a; color: #888; border: 1px solid #444; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s;";

    // X√≥a danh s√°ch c≈©
    listDiv.innerHTML = "";

    // Reset style t·∫•t c·∫£ c√°c n√∫t v·ªÅ Inactive tr∆∞·ªõc
    if(btnSpear) btnSpear.style.cssText = styleInactive;
    if(btnBlade) btnBlade.style.cssText = styleInactive;
    if(btnGun) btnGun.style.cssText = styleInactive;

    // --- X·ª¨ L√ù T·ª™NG TAB ---
    if (tabName === 'SPEAR') {
        if(btnSpear) btnSpear.style.cssText = styleActive;
        listDiv.innerHTML += createItemHTML("1007", "B√∫t Ch√¨ Th·∫ßn", 1000, "PENCIL");
    } 
    else if (tabName === 'BLADE') {
        if(btnBlade) btnBlade.style.cssText = styleActive;
        listDiv.innerHTML += createItemHTML("1024", "Th∆∞·ªõc K·∫ª ƒêao", 1000, "RULER");
    }
    // >>> M·ªöI: TAB S√öNG <<<
    else if (tabName === 'GUN') {
        if(btnGun) btnGun.style.cssText = styleActive;
        // G·ªçi h√†m t·∫°o B√∫t X√≥a
        listDiv.innerHTML += createItemHTML("1025", "S√∫ng B√∫t X√≥a", 1000, "CORRECTION_PEN");
    }
}

// 3. H√ÄM M·ªû C·ª¨A H√ÄNG (GI·ªú CH·ªà G·ªåI L·∫†I C√ÅC H√ÄM TR√äN)
function openShop(type) {
    const modal = document.getElementById("shopModal");
    const title = modal.querySelector("h2");
    const itemsDiv = document.getElementById("shopItems");
    
    itemsDiv.innerHTML = "";
    modal.style.display = "block";
    document.getElementById("interactBtn").style.display = "none";

    if (type === "PHARMACIST") {
        title.innerText = "‚öóÔ∏è D∆∞·ª£c Sƒ©";
        title.style.color = "#46c846"; 
        // L∆ØU √ù: Tham s·ªë ·∫£nh gi·ªù ƒë·ªÉ l√† '1013' cho t·∫•t c·∫£, code s·∫Ω t·ª± c·∫Øt d·ª±a tr√™n Type
        itemsDiv.innerHTML += createItemHTML("1013", "B√¨nh M√°u", 100, "HP_POTION");
        itemsDiv.innerHTML += createItemHTML("1013", "B√¨nh Mana", 100, "MP_POTION");
        itemsDiv.innerHTML += createItemHTML("1013", "B√¨nh H·ªón H·ª£p", 200, "DUAL_POTION");
        itemsDiv.innerHTML += createItemHTML("1013", "B√¨nh Th·ªÉ L·ª±c", 300, "STAMINA_POTION");
    } 
    else if (type === "BLACKSMITH") {
        // ... (Gi·ªØ nguy√™n logic Th·ª£ R√®n) ...
        title.innerText = "üî® Th·ª£ R√®n";
        title.style.color = "#ff4444"; 
        itemsDiv.innerHTML = `
            <div style="display: flex; gap: 5px; margin-bottom: 15px; padding-bottom: 5px;">
                <button id="btnTabSpear" onclick="switchBlacksmithTab('SPEAR')">üó°Ô∏è Th∆∞∆°ng</button>
                <button id="btnTabBlade" onclick="switchBlacksmithTab('BLADE')">üî™ ƒêao</button>
                <button id="btnTabGun" onclick="switchBlacksmithTab('GUN')">üî´ S√∫ng</button>
            </div>
            <div id="blacksmithList" style="min-height: 150px;"></div>
        `;
        setTimeout(() => switchBlacksmithTab('SPEAR'), 0);
    }
    else if (type === "DORAEMON") {
        // ... (Gi·ªØ nguy√™n logic Doraemon) ...
        title.innerText = "üö™ C·ª≠a H√†ng Pet";
        title.style.color = "#0096e1";
        // Th√™m Pet Slime ƒêen v√†o shop
       itemsDiv.innerHTML += createItemHTML("1003.png", "Slime ƒêen", 10000, "PET_SLIME");

    }
}

// --- H√†m ƒê√≥ng C·ª≠a H√†ng ---
function closeShop() {
    document.getElementById("shopModal").style.display = "none";
}

// --- H√†m Ki·ªÉm tra kho·∫£ng c√°ch ---
function updateNPCInteraction() {
    const btn = document.getElementById("interactBtn");
    const shop = document.getElementById("shopModal");
    if (shop.style.display === "block") return;

    let distPharmacist = Math.sqrt((player.x - NPC_PHARMACIST.x)**2 + (player.y - NPC_PHARMACIST.y)**2);
    let distBlacksmith = Math.sqrt((player.x - NPC_BLACKSMITH.x)**2 + (player.y - NPC_BLACKSMITH.y)**2);
    
    let distDoraemon = Math.sqrt((player.x - NPC_DORAEMON.x)**2 + (player.y - NPC_DORAEMON.y)**2);

    if (distPharmacist < NPC_PHARMACIST.interactDist) {
        btn.style.display = "block";
        btn.onclick = function() { openShop("PHARMACIST"); }; 
    } 
    else if (distBlacksmith < NPC_BLACKSMITH.interactDist) {
        btn.style.display = "block";
        btn.onclick = function() { openShop("BLACKSMITH"); }; 
    }
    else if (distDoraemon < NPC_DORAEMON.interactDist) {
        btn.style.display = "block";
        btn.innerHTML = "MUA"; // ƒê·∫£m b·∫£o n√∫t hi·ªán ch·ªØ Mua
        btn.onclick = function() { openShop("DORAEMON"); };
    }
    else {
        btn.style.display = "none";
    }
}

function buyItem(type, price, name, imgId) {
    if (inventory.gold >= price) {
        
   // --- X·ª¨ L√ù MUA PET SLIME ƒêEN ---
   if (type === "PET_SLIME") { // <--- Ki·ªÉm tra m√£ m·ªõi
    if (player.hasSlime) {
        alert("B·∫°n ƒë√£ c√≥ Slime ƒêen r·ªìi!");
        return;
    }
    inventory.gold -= price;
    player.hasSlime = true; // <--- C·∫≠p nh·∫≠t bi·∫øn hasSlime
    activePet = new PetSlime(player); // <--- G·ªçi class PetSlime
    
    saveGame(player, inventory, false);
    alert("ƒê√£ mua Slime ƒêen!");
    return;
}

        // Logic mua ƒë·ªì th∆∞·ªùng
        let added = inventory.addItem(type, 1, imgId);
        if (added) {
            inventory.gold -= price; 
            saveGame(player, inventory, false); 
            alert(`ƒê√£ mua th√†nh c√¥ng: ${name}`);
        } else {
            alert("H√†nh trang ƒë√£ ƒë·∫ßy!");
        }
    } else {
        alert(`B·∫°n kh√¥ng ƒë·ªß ƒê·∫≠u! C·∫ßn ${price} ü•ú, b·∫°n c√≥ ${inventory.gold} ü•ú`);
    }
}
// --- H√ÄM V·∫º H∆Ø·ªöNG D·∫™N ·ªû M√ÄN H√åNH CH·ªú ---
function drawStartScreenGuide() {
    let cx = 35, cy = 35; // T·ªça ƒë·ªô t√¢m Avatar (G√≥c tr√°i tr√™n)
    let time = Date.now() / 300; // T·ªëc ƒë·ªô nh·∫•p nh√°y
    
    // 1. V·∫Ω v√≤ng tr√≤n t·ªèa s√°ng bao quanh Avatar
    let pulseSize = 28 + Math.sin(time) * 4; // Co gi√£n t·ª´ 24px ƒë·∫øn 32px
    ctx.beginPath();
    ctx.arc(cx, cy, pulseSize, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 215, 0, ${0.6 + Math.sin(time)*0.3})`; // M√†u v√†ng
    ctx.lineWidth = 3;
    ctx.stroke();

    // 2. V·∫Ω M≈©i t√™n m√†u ƒë·ªè ch·ªâ v√†o Avatar
    let arrowX = cx + 60 + Math.sin(time) * 10; // M≈©i t√™n th·ª•t th√≤
    let arrowY = cy;
    
    ctx.save();
    ctx.translate(arrowX, arrowY);
    
    // V·∫Ω h√¨nh tam gi√°c (ƒë·∫ßu m≈©i t√™n)
    ctx.fillStyle = "#ff4444";
    ctx.beginPath();
    ctx.moveTo(0, 0);       // ƒê·ªânh nh·ªçn h∆∞·ªõng v·ªÅ Avatar
    ctx.lineTo(15, -10);
    ctx.lineTo(15, 10);
    ctx.fill();
    
    // V·∫Ω ƒëu√¥i m≈©i t√™n
    ctx.fillRect(15, -4, 25, 8);
    
    // 3. V·∫Ω ch·ªØ h∆∞·ªõng d·∫´n c·∫°nh m≈©i t√™n
    ctx.font = "bold 14px Arial";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("B·∫§M V√ÄO ƒê√ÇY ƒê·ªÇ T·∫†O", 45, 0);
    
    ctx.restore();
}
// --- X·ª¨ L√ù N√öT BACK V√Ä T·ª∞ ƒê·ªòNG L∆ØU ---
history.pushState(null, null, location.href);
window.onpopstate = function () {
    // Ch·ªâ l∆∞u game v√† th√¥ng b√°o, kh√¥ng chuy·ªÉn trang n·ªØa
    saveGame(player, inventory, false);
    alert("ƒê√£ l∆∞u game! B·∫°n c√≥ th·ªÉ ƒë√≥ng tr√¨nh duy·ªát.");
    // Ho·∫∑c n·∫øu mu·ªën ƒë√≥ng tab lu√¥n (t√πy tr√¨nh duy·ªát h·ªó tr·ª£):
    // window.close(); 
};

// L∆∞u khi ·∫©n ·ª©ng d·ª•ng (Home/Tab kh√°c)
document.addEventListener("visibilitychange", () => {
    if (document.hidden) saveGame(player, inventory, true);
});

// L∆∞u d·ª± ph√≤ng khi ƒë√≥ng h·∫≥n tr√¨nh duy·ªát
window.addEventListener("beforeunload", () => {
    saveGame(player, inventory, true);
});
// --- H√ÄM X·ª¨ L√ù N√öT NG·ªíI THI·ªÄN ---
function toggleSit() {
    if (!player) return;

    // Ch·ªâ ƒë·ªïi tr·∫°ng th√°i ng·ªìi/ƒë·ª©ng
    player.isSitting = !player.isSitting;

    if (player.isSitting) {
        player.sitTimer = 0; 
        // Hi·ªáu ·ª©ng ch·ªØ bay
        if (typeof floatingTexts !== 'undefined') {
            floatingTexts.push(new FloatingText(player.x, player.y - 60, "T·ªãnh T√¢m...", "#00ff00"));
        }
    }
}
// KH·ªûI CH·∫†Y GAME T·∫†I ƒê√ÇY (SAU KHI M·ªåI TH·ª® ƒê√É S·∫¥N S√ÄNG)
const game = new Phaser.Game(config);
// --- 2. H√ÄM KI·ªÇM TRA VA CH·∫†M ---
function checkCollision(targetX, targetY) {
    // A. KI·ªÇM TRA BI√äN GI·ªöI B·∫¢N ƒê·ªí (COLLISION MAP BOUNDS)
    
    // 1. Ki·ªÉm tra hai b√™n Tr√°i / Ph·∫£i (Gi·ªØ nguy√™n)
    if (targetX < 20 || targetX > WORLD_WIDTH - 20) return true;

    // 2. Ki·ªÉm tra ƒê√°y b·∫£n ƒë·ªì (Gi·ªØ nguy√™n)
    if (targetY > WORLD_HEIGHT - 20) return true;

    // 3. Ki·ªÉm tra m√©p tr√™n b·∫£n ƒë·ªì
    if (targetY < 20) return true;

    // B. KI·ªÇM TRA VA CH·∫†M V·ªöI NPC (Gi·ªØ nguy√™n ƒëo·∫°n d∆∞·ªõi n√†y)
    let npcs = [NPC_PHARMACIST, NPC_DORAEMON, NPC_BLACKSMITH];
    for (let npc of npcs) {
        let dist = Math.sqrt((targetX - npc.x)**2 + (targetY - npc.y)**2);
        if (dist < NPC_HITBOX_SIZE) {
            return true; 
        }
    }

    // C. KI·ªÇM TRA VA CH·∫†M V·ªöI V·∫¨T C·∫¢N (Gi·ªØ nguy√™n ƒëo·∫°n d∆∞·ªõi n√†y)
    let playerFeet = {
        left: targetX - 10,   
        right: targetX + 10,
        top: targetY - 5,     
        bottom: targetY + 5
    };

    for (let obs of OBSTACLES) {
        if (obs.type === 'RECT') {
            if (playerFeet.right > obs.x && 
                playerFeet.left < obs.x + obs.w && 
                playerFeet.bottom > obs.y && 
                playerFeet.top < obs.y + obs.h) {
                return true; 
            }
        } 
        else if (obs.type === 'CIRCLE') {
            let dist = Math.sqrt((targetX - obs.x)**2 + (targetY - obs.y)**2);
            if (dist < obs.r + 10) {
                return true; 
            }
        }
    }

    return false; // Kh√¥ng ƒë·ª•ng g√¨ c·∫£, ƒëi ƒë∆∞·ª£c!
}
// --- 4. H√ÄM V·∫º V·∫¨T C·∫¢N ---
function drawObstacles(camX, camY) {
    for (let obs of OBSTACLES) {
        // T√≠nh to·∫° ƒë·ªô v·∫Ω tr√™n m√†n h√¨nh (tr·ª´ ƒëi Camera)
        let drawX = obs.x - camX;
        let drawY = obs.y - camY;

        // Ch·ªâ v·∫Ω n·∫øu n·∫±m trong m√†n h√¨nh (T·ªëi ∆∞u hi·ªáu nƒÉng)
        if (drawX + (obs.w || obs.r*2) < 0 || drawX > SCREEN_WIDTH ||
            drawY + (obs.h || obs.r*2) < 0 || drawY > SCREEN_HEIGHT) continue;

        ctx.fillStyle = obs.color;
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 2;

        if (obs.type === 'RECT') {
            // V·∫Ω b√≥ng ƒë·ªï nh·∫π
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.fillRect(drawX + 5, drawY + obs.h - 5, obs.w, 10);
            
            // V·∫Ω kh·ªëi
            ctx.fillStyle = obs.color;
            ctx.fillRect(drawX, drawY, obs.w, obs.h);
            ctx.strokeRect(drawX, drawY, obs.w, obs.h);
        } 
        else if (obs.type === 'CIRCLE') {
            // V·∫Ω b√≥ng ƒë·ªï tr√≤n
            ctx.beginPath();
            ctx.arc(drawX + obs.r + 5, drawY + obs.r + 5, obs.r, 0, Math.PI*2);
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.fill();

            // V·∫Ω kh·ªëi tr√≤n
            ctx.beginPath();
            ctx.arc(drawX + obs.r, drawY + obs.r, obs.r, 0, Math.PI*2);
            ctx.fillStyle = obs.color;
            ctx.fill();
            ctx.stroke();
        }
    }
}
// H√†m v·∫Ω l∆∞·ªõi chuy√™n d·ª•ng (Ch·ªâ v·∫Ω g·ªçn g√†ng b√™n trong t·ªù gi·∫•y)
function drawGridLinesOnly() {
    let gridW = 40; // K√≠ch th∆∞·ªõc 1 √¥ ly

    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#a2d5f2"; // M√†u m·ª±c xanh nh·∫°t (chu·∫©n √¥ ly v·ªü)

    // V·∫Ω c√°c ƒë∆∞·ªùng d·ªçc (Ch·ªâ v·∫Ω t·ª´ x=0 ƒë·∫øn h·∫øt WORLD_WIDTH)
    for (let x = 0; x <= WORLD_WIDTH; x += gridW) { 
        ctx.moveTo(x, 0); 
        ctx.lineTo(x, WORLD_HEIGHT); 
    }
    // V·∫Ω c√°c ƒë∆∞·ªùng ngang (Ch·ªâ v·∫Ω t·ª´ y=0 ƒë·∫øn h·∫øt WORLD_HEIGHT)
    for (let y = 0; y <= WORLD_HEIGHT; y += gridW) { 
        ctx.moveTo(0, y); 
        ctx.lineTo(WORLD_WIDTH, y); 
    }
    ctx.stroke();
    
    // V·∫Ω l·ªÅ ƒë·ªè (ƒê∆∞·ªùng k·∫ª d·ªçc m√†u ƒë·ªè c·ªë ƒë·ªãnh ·ªü t·ªça ƒë·ªô X = 200)
    ctx.beginPath();
    ctx.moveTo(200, 0);
    ctx.lineTo(200, WORLD_HEIGHT);
    ctx.strokeStyle = "#ff7b7b"; // M√†u m·ª±c ƒë·ªè nh·∫°t
    ctx.lineWidth = 2.5;         
    ctx.stroke();
}
</script>
</body>
</html>